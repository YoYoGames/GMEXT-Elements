// #####################################################################
// # Schema Definitions (auto-generated, DO NOT EDIT)
// #####################################################################

/**
 * @func ElementsMetadataSpecProperty()
 * @param {String} _name The unique name of the field
 * @param {String} _display_name The display name of the field
 * @param {String} _type The field type (one of: STRING | NUMBER | BOOLEAN | ARRAY | ENUM | OBJECT | TAGS)
 * @param {Real} _required True if the field is required.
 * @param {String} _placeholder The placeholder description when displaying in the editor.
 * @param {Struct} _default_value The default description, null if left unspecified.
 * @param {Array[Struct.ElementsMetadataSpecProperty]} _properties
 */
function ElementsMetadataSpecProperty(_name, _display_name, _type, _required = undefined, _placeholder = undefined, _default_value = undefined, _properties = undefined) constructor
{
	name = _name;
	displayName = _display_name;
	type = _type;
	required = _required;
	placeholder = _placeholder;
	defaultValue = _default_value;
	properties = _properties;
}

/**
 * @func ElementsMetadataSpec()
 * @param {String} _id The unique ID of the schema itself.
 * @param {String} _name The Name of the schema.
 * @param {String} _type The type of the tab itself. (one of: STRING | NUMBER | BOOLEAN | ARRAY | ENUM | OBJECT | TAGS)
 * @param {Array[Struct.ElementsMetadataSpecProperty]} _properties The tabs of the metadata spec.
 */
function ElementsMetadataSpec(_id, _name, _type, _properties) constructor
{
	id = _id;
	name = _name;
	type = _type;
	properties = _properties;
}

/**
 * @func ElementsItem()
 * @param {String} _name
 * @param {String} _display_name
 * @param {String} _description
 * @param {String} _category  (one of: FUNGIBLE | DISTINCT)
 * @param {String} _id
 * @param {Array[String]} _tags
 * @param {Struct.ElementsMetadataSpec} _metadata_spec Represents a spec for metadata.
 * @param {Struct} _metadata
 * @param {Real} _public_visible
 */
function ElementsItem(_name, _display_name, _description, _category, _id = undefined, _tags = undefined, _metadata_spec = undefined, _metadata = undefined, _public_visible = undefined) constructor
{
	name = _name;
	displayName = _display_name;
	description = _description;
	category = _category;
	id = _id;
	tags = _tags;
	metadataSpec = _metadata_spec;
	metadata = _metadata;
	publicVisible = _public_visible;
}

/**
 * @func ElementsUser()
 * @param {String} _id The user's database assigned unique ID.
 * @param {String} _level The user's access level. (one of: UNPRIVILEGED | USER | SUPERUSER)
 * @param {String} _name A unique name for the user.
 * @param {String} _first_name The user's first name
 * @param {String} _last_name The user's last name
 * @param {String} _email The user's email.
 * @param {String} _primary_phone_nb The user's phone number.
 * @param {Array[String]} _linked_accounts List of linked account or auth scheme names.
 */
function ElementsUser(_id, _level, _name = undefined, _first_name = undefined, _last_name = undefined, _email = undefined, _primary_phone_nb = undefined, _linked_accounts = undefined) constructor
{
	id = _id;
	level = _level;
	name = _name;
	firstName = _first_name;
	lastName = _last_name;
	email = _email;
	primaryPhoneNb = _primary_phone_nb;
	linkedAccounts = _linked_accounts;
}

/**
 * @func ElementsRewardIssuance()
 * @param {String} _id The unique ID of the issuance.
 * @param {Struct.ElementsUser} _user The User associated with this Profile.
 * @param {String} _state The state of the reward. On creation, this is automatically assigned to be ISSUED. If the current value of the state is REDEEMED, then the state is no longer allowed to be updated. This valuemay not be directly modified--the redeem DAO method should be used instead to perform the redemption process. (one of: ISSUED | REDEEMED)
 * @param {String} _context A generic String used to uniquely identify the RewardIssuance issuance. If the RewardIssuance is created by the client, this value must be specified to prevent erroneous duplicate issuances. E.g. if the client successfully submits an issuance but fails to receive the response, the client is expected to submit a new issuance with the same context string. Similarly, the client application should have safeguards in place in the event of a crash to prevent duplicate submissions: e.g. ensuring that the context string is unchanged when performing multiple issuances of the same RewardIssuance. If the RewardIssuance is generated by the server, this will be defined automatically. The context cannot be updated after creation. Note that an context defined via the API should not begin with 'server.' as that is a protected namespace.
 * @param {String} _type Defines whether multiple issuances for the given user+reward+context may occur. If the type is set to NON_PERSISTENT, at most one ISSUED RewardIssuance may exist in the server at a time for a given user and context. If the type is set to PERSISTENT, at most one ISSUED or REDEEMED RewardIssuance may exist in the server for a given user and context, i.e. once a PERSISTENT RewardIssuance has been submitted, a new one may never be submitted and will be rejected by the server. Note that this value cannot be updated. By default, this will be set to NON_PERSISTENT. (one of: PERSISTENT | NON_PERSISTENT)
 * @param {Struct.ElementsItem} _item The Item to be issued upon redemption.
 * @param {Real} _item_quantity The amount of Items to be set/added to the InventoryItem upon redemption.
 * @param {String} _source Identifies the source of the issuance, e.g. 'Client', 'IAP', 'Leaderboard'. This may be specified manually by the client if desired. Note that this value cannot be updated.
 * @param {Struct} _metadata Metadata for the issuance. May be optionally defined by the client on creation. If the source is a server-side value, then a predefined structure will always be followed that provides additional information as to the source of the issuance (e.g. mission progress/step information).
 * @param {Array[String]} _tags The tags used to categorize this Reward Issuance.
 * @param {Real} _expiration_timestamp Optionally define when the issuance should expire. This value may be updated to extend when the expiration occurs. When set, this value must be greater than the current time on the server.Note that the record may not actually be deleted for up to sixty seconds after the time noted in thetimestamp.
 * @param {String} _uuid Internal unique identifier generated and assigned on creation.
 */
function ElementsRewardIssuance(_id, _user, _state, _context, _type, _item = undefined, _item_quantity = undefined, _source = undefined, _metadata = undefined, _tags = undefined, _expiration_timestamp = undefined, _uuid = undefined) constructor
{
	id = _id;
	user = _user;
	state = _state;
	context = _context;
	type = _type;
	item = _item;
	itemQuantity = _item_quantity;
	source = _source;
	metadata = _metadata;
	tags = _tags;
	expirationTimestamp = _expiration_timestamp;
	uuid = _uuid;
}

/**
 * @func ElementsCreateAppleIapReceipt()
 * @param {String} _receipt_data The base64-encoded string of the raw IAP receipt.
 * @param {String} _create_apple_iap_receipt_environment  (one of: SANDBOX | PRODUCTION)
 */
function ElementsCreateAppleIapReceipt(_receipt_data, _create_apple_iap_receipt_environment = undefined) constructor
{
	receiptData = _receipt_data;
	createAppleIapReceiptEnvironment = _create_apple_iap_receipt_environment;
}

/**
 * @func ElementsApplicationConfiguration()
 * @param {String} _id The database assigned ID for the application configuration.
 * @param {String} _name The application-configuration specific unique ID. Unique per application per category.
 * @param {String} _type The fully-qualified Java type of ApplicationConfiguration.
 * @param {String} _description
 * @param {Struct.ElementsApplication} _parent
 */
function ElementsApplicationConfiguration(_id, _name, _type, _description, _parent) constructor
{
	id = _id;
	name = _name;
	type = _type;
	description = _description;
	parent = _parent;
}

/**
 * @func ElementsApplication()
 * @param {String} _name
 * @param {String} _id
 * @param {String} _description
 * @param {String} _git_branch
 * @param {String} _script_repo_url
 * @param {String} _http_documentation_url
 * @param {String} _http_documentation_ui_url
 * @param {String} _http_tunnel_endpoint_url
 * @param {Struct} _attributes
 * @param {Struct.ElementsApplicationConfiguration} _application_configuration
 */
function ElementsApplication(_name, _id = undefined, _description = undefined, _git_branch = undefined, _script_repo_url = undefined, _http_documentation_url = undefined, _http_documentation_ui_url = undefined, _http_tunnel_endpoint_url = undefined, _attributes = undefined, _application_configuration = undefined) constructor
{
	name = _name;
	id = _id;
	description = _description;
	gitBranch = _git_branch;
	scriptRepoUrl = _script_repo_url;
	httpDocumentationUrl = _http_documentation_url;
	httpDocumentationUiUrl = _http_documentation_ui_url;
	httpTunnelEndpointUrl = _http_tunnel_endpoint_url;
	attributes = _attributes;
	applicationConfiguration = _application_configuration;
}

/**
 * @func ElementsPaginationApplicationConfiguration()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsApplicationConfiguration]} _objects
 */
function ElementsPaginationApplicationConfiguration(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsCreateApplicationRequest()
 * @param {String} _name
 * @param {String} _description
 * @param {Struct} _attributes
 */
function ElementsCreateApplicationRequest(_name, _description = undefined, _attributes = undefined) constructor
{
	name = _name;
	description = _description;
	attributes = _attributes;
}

/**
 * @func ElementsPaginationApplication()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsApplication]} _objects
 */
function ElementsPaginationApplication(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsUpdateApplicationRequest()
 * @param {String} _name
 * @param {String} _description
 * @param {Struct} _attributes
 */
function ElementsUpdateApplicationRequest(_name, _description = undefined, _attributes = undefined) constructor
{
	name = _name;
	description = _description;
	attributes = _attributes;
}

/**
 * @func ElementsFacebookApplicationConfiguration()
 * @param {String} _id The database assigned ID for the application configuration.
 * @param {String} _name The application-configuration specific unique ID. Unique per application per category.
 * @param {String} _type The fully-qualified Java type of ApplicationConfiguration.
 * @param {String} _description
 * @param {Struct.ElementsApplication} _parent
 * @param {String} _application_id The AppID as it appears in the Facebook Developer Console
 * @param {String} _application_secret The App Secret as it appears in the Facebook Developer Console
 * @param {Array[String]} _builtin_application_permissions The set of built-in permissions connected clients will need to request.
 */
function ElementsFacebookApplicationConfiguration(_id, _name, _type, _description, _parent, _application_id, _application_secret, _builtin_application_permissions = undefined) constructor
{
	id = _id;
	name = _name;
	type = _type;
	description = _description;
	parent = _parent;
	applicationId = _application_id;
	applicationSecret = _application_secret;
	builtinApplicationPermissions = _builtin_application_permissions;
}

/**
 * @func ElementsFirebaseApplicationConfiguration()
 * @param {String} _id The database assigned ID for the application configuration.
 * @param {String} _name The application-configuration specific unique ID. Unique per application per category.
 * @param {String} _type The fully-qualified Java type of ApplicationConfiguration.
 * @param {String} _description
 * @param {Struct.ElementsApplication} _parent
 * @param {String} _project_id The contents of the serviceAccountCredentials.json file.
 * @param {String} _service_account_credentials The contents of the serviceAccountCredentials.json file.
 */
function ElementsFirebaseApplicationConfiguration(_id, _name, _type, _description, _parent, _project_id, _service_account_credentials) constructor
{
	id = _id;
	name = _name;
	type = _type;
	description = _description;
	parent = _parent;
	projectId = _project_id;
	serviceAccountCredentials = _service_account_credentials;
}

/**
 * @func ElementsProductBundleReward()
 * @param {String} _item_id The id of the item to be rewarded.
 * @param {Real} _quantity The quantity of the item to be rewarded.
 */
function ElementsProductBundleReward(_item_id, _quantity) constructor
{
	itemId = _item_id;
	quantity = _quantity;
}

/**
 * @func ElementsProductBundle()
 * @param {String} _product_id The platform-specific unique SKU/product identifier that, when purchased, will result in the items in this product bundle to be issued to the user.
 * @param {Array[Struct.ElementsProductBundleReward]} _product_bundle_rewards The list of product bundle rewards that will be issued to the user upon purchase.
 * @param {Real} _display Whether or not the frontend should display this product bundle to end users.
 * @param {String} _display_name The title of the product bundle to display to end users.
 * @param {String} _description The description of the product bundle to display to end users.
 * @param {Struct} _metadata Application-specific metadata.
 */
function ElementsProductBundle(_product_id, _product_bundle_rewards, _display, _display_name = undefined, _description = undefined, _metadata = undefined) constructor
{
	productId = _product_id;
	productBundleRewards = _product_bundle_rewards;
	display = _display;
	displayName = _display_name;
	description = _description;
	metadata = _metadata;
}

/**
 * @func ElementsGooglePlayApplicationConfiguration()
 * @param {String} _id The database assigned ID for the application configuration.
 * @param {String} _name The application-configuration specific unique ID. Unique per application per category.
 * @param {String} _type The fully-qualified Java type of ApplicationConfiguration.
 * @param {String} _description
 * @param {Struct.ElementsApplication} _parent
 * @param {String} _application_id
 * @param {Struct} _json_key
 * @param {Array[Struct.ElementsProductBundle]} _product_bundles The list of product bundles that may be rewarded upon successful IAP transactions.
 */
function ElementsGooglePlayApplicationConfiguration(_id, _name, _type, _description, _parent, _application_id = undefined, _json_key = undefined, _product_bundles = undefined) constructor
{
	id = _id;
	name = _name;
	type = _type;
	description = _description;
	parent = _parent;
	applicationId = _application_id;
	jsonKey = _json_key;
	productBundles = _product_bundles;
}

/**
 * @func ElementsIosApplicationConfiguration()
 * @param {String} _id The database assigned ID for the application configuration.
 * @param {String} _name The application-configuration specific unique ID. Unique per application per category.
 * @param {String} _type The fully-qualified Java type of ApplicationConfiguration.
 * @param {String} _description
 * @param {Struct.ElementsApplication} _parent
 * @param {String} _application_id
 * @param {Array[Struct.ElementsProductBundle]} _product_bundles The list of product bundles that may be rewarded upon successful IAP transactions.
 */
function ElementsIosApplicationConfiguration(_id, _name, _type, _description, _parent, _application_id, _product_bundles = undefined) constructor
{
	id = _id;
	name = _name;
	type = _type;
	description = _description;
	parent = _parent;
	applicationId = _application_id;
	productBundles = _product_bundles;
}

/**
 * @func ElementsElementServiceReference()
 * @param {String} _element_name The name of the Element to reference.
 * @param {String} _service_type Specifies the type of the service within the Element. May be null.
 * @param {String} _service_name Specifies the name of the service within the Element. May be null.
 */
function ElementsElementServiceReference(_element_name, _service_type = undefined, _service_name = undefined) constructor
{
	elementName = _element_name;
	serviceType = _service_type;
	serviceName = _service_name;
}

/**
 * @func ElementsCallbackDefinition()
 * @param {String} _method Specifies the method to invoke.
 * @param {Struct.ElementsElementServiceReference} _service Describes the matchmaker (dev.getelements.elements.sdk.dao.Matchmaker) to use for this configuration.
 */
function ElementsCallbackDefinition(_method, _service) constructor
{
	self[$ "method"] = _method;
	service = _service;
}

/**
 * @func ElementsMatchmakingApplicationConfiguration()
 * @param {String} _id The database assigned ID for the application configuration.
 * @param {String} _name The application-configuration specific unique ID. Unique per application per category.
 * @param {String} _type The fully-qualified Java type of ApplicationConfiguration.
 * @param {String} _description
 * @param {Struct.ElementsApplication} _parent
 * @param {Struct.ElementsCallbackDefinition} _success Defines a script method and a module to invoke.
 * @param {Struct.ElementsElementServiceReference} _matchmaker Describes the matchmaker (dev.getelements.elements.sdk.dao.Matchmaker) to use for this configuration.
 * @param {Real} _max_profiles The maximum number of profiles that can be matched in a single match.
 * @param {Struct} _metadata The metadata for this matchmaking configuration. This will be copied to the match when it is created.
 * @param {Struct.ElementsMetadataSpec} _metadata_spec Represents a spec for metadata.
 */
function ElementsMatchmakingApplicationConfiguration(_id, _name, _type, _description, _parent, _success = undefined, _matchmaker = undefined, _max_profiles = undefined, _metadata = undefined, _metadata_spec = undefined) constructor
{
	id = _id;
	name = _name;
	type = _type;
	description = _description;
	parent = _parent;
	success = _success;
	matchmaker = _matchmaker;
	maxProfiles = _max_profiles;
	metadata = _metadata;
	metadataSpec = _metadata_spec;
}

/**
 * @func ElementsPSNApplicationConfiguration()
 * @param {String} _id The database assigned ID for the application configuration.
 * @param {String} _name The application-configuration specific unique ID. Unique per application per category.
 * @param {String} _type The fully-qualified Java type of ApplicationConfiguration.
 * @param {String} _description
 * @param {Struct.ElementsApplication} _parent
 * @param {String} _np_identifier
 * @param {String} _client_secret
 */
function ElementsPSNApplicationConfiguration(_id, _name, _type, _description, _parent, _np_identifier, _client_secret) constructor
{
	id = _id;
	name = _name;
	type = _type;
	description = _description;
	parent = _parent;
	npIdentifier = _np_identifier;
	clientSecret = _client_secret;
}

/**
 * @func ElementsAuthScheme()
 * @param {String} _id The unique ID of the auth scheme.
 * @param {String} _audience A unique name used to identify the scheme within the instance of Elements.
 * @param {String} _public_key A base-64 encoded string representing an x509 encoded public key.
 * @param {String} _algorithm The digital signature matching the public key format. (one of: RSA_256 | RSA_384 | RSA_512)
 * @param {String} _user_level The highest permitted user level this particular scheme will authorize. (one of: UNPRIVILEGED | USER | SUPERUSER)
 * @param {Array[String]} _tags The tags used to tag this auth scheme.
 * @param {Array[String]} _allowed_issuers A list of issuers allowed to use this scheme.
 */
function ElementsAuthScheme(_id, _audience, _public_key, _algorithm, _user_level, _tags, _allowed_issuers) constructor
{
	id = _id;
	audience = _audience;
	publicKey = _public_key;
	algorithm = _algorithm;
	userLevel = _user_level;
	tags = _tags;
	allowedIssuers = _allowed_issuers;
}

/**
 * @func ElementsCreateAuthSchemeResponse()
 * @param {Struct.ElementsAuthScheme} _scheme The full JSON response as described in AuthScheme
 * @param {String} _public_key The Base64 public key that was either given or generated during creation. See https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/security/spec/X509EncodedKeySpec.html for details on the specifics of the format.
 * @param {String} _private_key The Base64 public key that was either given or generated during creation. See https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/security/spec/PKCS8EncodedKeySpec.html for details on the specifics of the format.
 */
function ElementsCreateAuthSchemeResponse(_scheme, _public_key, _private_key = undefined) constructor
{
	scheme = _scheme;
	publicKey = _public_key;
	privateKey = _private_key;
}

/**
 * @func ElementsCreateAuthSchemeRequest()
 * @param {String} _audience The JWT audience for the scheme. Must be unique.
 * @param {String} _algorithm  (one of: RSA_256 | RSA_384 | RSA_512)
 * @param {String} _user_level The highest permitted user level this particular scheme will authorize. (one of: UNPRIVILEGED | USER | SUPERUSER)
 * @param {Array[String]} _tags A list of tags used to index the auth scheme.
 * @param {Array[String]} _allowed_issuers The list of issuers allowed to use this scheme.
 * @param {String} _public_key The Base64 public key that was either given or generated during creation. See https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/security/spec/X509EncodedKeySpec.html for details on the specifics of the format.
 */
function ElementsCreateAuthSchemeRequest(_audience, _algorithm, _user_level, _tags, _allowed_issuers, _public_key = undefined) constructor
{
	audience = _audience;
	algorithm = _algorithm;
	userLevel = _user_level;
	tags = _tags;
	allowedIssuers = _allowed_issuers;
	publicKey = _public_key;
}

/**
 * @func ElementsPaginationAuthScheme()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsAuthScheme]} _objects
 */
function ElementsPaginationAuthScheme(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsUpdateAuthSchemeResponse()
 * @param {String} _public_key The Base64 public key that was either given or generated during creation. See https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/security/spec/X509EncodedKeySpec.html for details on the specifics of the format.
 * @param {Struct.ElementsAuthScheme} _scheme The full JSON response as described in AuthScheme
 * @param {String} _private_key The Base64 public key that was either given or generated during creation. See https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/security/spec/PKCS8EncodedKeySpec.html for details on the specifics of the format.
 */
function ElementsUpdateAuthSchemeResponse(_public_key, _scheme = undefined, _private_key = undefined) constructor
{
	publicKey = _public_key;
	scheme = _scheme;
	privateKey = _private_key;
}

/**
 * @func ElementsUpdateAuthSchemeRequest()
 * @param {String} _audience The JWT audience for the scheme. Must be unique.
 * @param {String} _algorithm The algorithm that Elements will use with the supplied key. (one of: RSA_256 | RSA_384 | RSA_512)
 * @param {String} _user_level The highest permitted user level this particular scheme will authorize. (one of: UNPRIVILEGED | USER | SUPERUSER)
 * @param {Array[String]} _tags The list of tags for tagging the auth scheme.
 * @param {Array[String]} _allowed_issuers The list of issuers allowed to use this scheme.
 * @param {Real} _regenerate If set to true, Elements will regenerate the key and pubKey must be null or omitted
 * @param {String} _public_key The Base64 public key that was either given or generated during creation. See https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/security/spec/X509EncodedKeySpec.html for details on the specifics of the format.
 */
function ElementsUpdateAuthSchemeRequest(_audience, _algorithm, _user_level, _tags, _allowed_issuers, _regenerate = undefined, _public_key = undefined) constructor
{
	audience = _audience;
	algorithm = _algorithm;
	userLevel = _user_level;
	tags = _tags;
	allowedIssuers = _allowed_issuers;
	regenerate = _regenerate;
	publicKey = _public_key;
}

/**
 * @func ElementsLargeObjectReference()
 * @param {String} _id The unique ID of the LargeObject.
 * @param {String} _url The URL where the binary contents of the LargeObject may be read.
 * @param {String} _mime_type The MIME type of the LargeObject.
 * @param {String} _state Current state of the LargeObject. (one of: EMPTY | UPLOADED)
 * @param {String} _last_modified Date of last modification
 */
function ElementsLargeObjectReference(_id = undefined, _url = undefined, _mime_type = undefined, _state = undefined, _last_modified = undefined) constructor
{
	id = _id;
	url = _url;
	mimeType = _mime_type;
	state = _state;
	lastModified = _last_modified;
}

/**
 * @func ElementsProfile()
 * @param {String} _id The unique ID of the profile itself.
 * @param {Struct.ElementsUser} _user The User associated with this Profile.
 * @param {Struct.ElementsApplication} _application
 * @param {String} _display_name A non-unique display name for this profile.
 * @param {String} _image_url A URL to the image of the profile.  (ie the User's Avatar).
 * @param {Struct.ElementsLargeObjectReference} _image_object Image object stored in EL large objects storage.
 * @param {Struct} _metadata An object containing arbitrary player metadata as key-value pairs.
 * @param {Real} _last_login The last time this profile has been logged in by the user.
 */
function ElementsProfile(_id, _user, _application, _display_name, _image_url = undefined, _image_object = undefined, _metadata = undefined, _last_login = undefined) constructor
{
	id = _id;
	user = _user;
	application = _application;
	displayName = _display_name;
	imageUrl = _image_url;
	imageObject = _image_object;
	metadata = _metadata;
	lastLogin = _last_login;
}

/**
 * @func ElementsSession()
 * @param {Struct.ElementsUser} _user The User associated with this Profile.
 * @param {Struct.ElementsProfile} _profile
 * @param {Struct.ElementsApplication} _application
 * @param {Real} _expiry
 */
function ElementsSession(_user, _profile = undefined, _application = undefined, _expiry = undefined) constructor
{
	user = _user;
	profile = _profile;
	application = _application;
	expiry = _expiry;
}

/**
 * @func ElementsSessionCreation()
 * @param {String} _session_secret The Session Secret to pass to subsequent requests through headers.
 * @param {Struct.ElementsSession} _session The Session object generated by the request.
 */
function ElementsSessionCreation(_session_secret = undefined, _session = undefined) constructor
{
	sessionSecret = _session_secret;
	session = _session;
}

/**
 * @func ElementsOAuth2SessionRequest()
 * @param {String} _scheme_id The OAuth2 scheme ID to use.
 * @param {Struct} _request_parameters The request parameters to be used in the token validation request. This should adhere to any params marked as fromClient in the auth scheme.
 * @param {Struct} _request_headers The request headers to be used in the token validation request. This should adhere to any headers marked as fromClient in the auth scheme.
 * @param {String} _profile_id The profile ID to assign to the session.
 * @param {String} _profile_selector A query string to select the profile to use. NOTE: This will not be run if a profileId is specified.
 */
function ElementsOAuth2SessionRequest(_scheme_id, _request_parameters = undefined, _request_headers = undefined, _profile_id = undefined, _profile_selector = undefined) constructor
{
	schemeId = _scheme_id;
	requestParameters = _request_parameters;
	requestHeaders = _request_headers;
	profileId = _profile_id;
	profileSelector = _profile_selector;
}

/**
 * @func ElementsOAuth2RequestKeyValue()
 * @param {String} _key The key.
 * @param {String} _value The value.
 * @param {Real} _from_client If this value should be received from the client, or predefined and stored in the DB.
 */
function ElementsOAuth2RequestKeyValue(_key = undefined, _value = undefined, _from_client = undefined) constructor
{
	key = _key;
	value = _value;
	fromClient = _from_client;
}

/**
 * @func ElementsOAuth2AuthScheme()
 * @param {String} _id The unique ID of the auth scheme.
 * @param {String} _name A unique name used to identify the scheme within the instance of Elements. If using the same OAuth2 provider (e.g. Steam), it is recommended to suffix the name for each application when using multitenancy, e.g. steam_game1, steam_game2, etc.
 * @param {String} _validation_url The URL to send the user token validation request to.
 * @param {Array[Struct.ElementsOAuth2RequestKeyValue]} _headers The headers required for the validation request.
 * @param {Array[Struct.ElementsOAuth2RequestKeyValue]} _params The query parameters required for the validation request.
 * @param {String} _response_id_mapping Determines how to map the user id in the response. For example "response.params.steamid"
 */
function ElementsOAuth2AuthScheme(_id, _name, _validation_url, _headers = undefined, _params = undefined, _response_id_mapping = undefined) constructor
{
	id = _id;
	name = _name;
	validationUrl = _validation_url;
	headers = _headers;
	params = _params;
	responseIdMapping = _response_id_mapping;
}

/**
 * @func ElementsCreateOrUpdateOAuth2AuthSchemeResponse()
 * @param {Struct.ElementsOAuth2AuthScheme} _scheme The full JSON response as described in AuthScheme
 */
function ElementsCreateOrUpdateOAuth2AuthSchemeResponse(_scheme = undefined) constructor
{
	scheme = _scheme;
}

/**
 * @func ElementsCreateOrUpdateOAuth2AuthSchemeRequest()
 * @param {String} _id The unique ID of the auth scheme.
 * @param {String} _name A unique name used to identify the scheme within the instance of Elements. If using the same OAuth2 provider (e.g. Steam), it is recommended to suffix the name for each application when using multitenancy, e.g. steam_game1, steam_game2, etc.
 * @param {String} _validation_url The URL to send the user token validation request to.
 * @param {Array[Struct.ElementsOAuth2RequestKeyValue]} _headers The headers required for the validation request.
 * @param {Array[Struct.ElementsOAuth2RequestKeyValue]} _params The query parameters required for the validation request.
 * @param {String} _response_id_mapping Determines how to map the user id in the response. For example "response.params.steamid"
 */
function ElementsCreateOrUpdateOAuth2AuthSchemeRequest(_id, _name, _validation_url, _headers = undefined, _params = undefined, _response_id_mapping = undefined) constructor
{
	id = _id;
	name = _name;
	validationUrl = _validation_url;
	headers = _headers;
	params = _params;
	responseIdMapping = _response_id_mapping;
}

/**
 * @func ElementsPaginationOAuth2AuthScheme()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsOAuth2AuthScheme]} _objects
 */
function ElementsPaginationOAuth2AuthScheme(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsOidcSessionRequest()
 * @param {String} _jwt The JWT to parse
 * @param {String} _profile_id The profile ID to assign to the session.
 * @param {String} _profile_selector A query string to select the profile to use. NOTE: This will not be run if a profileId is specified.
 */
function ElementsOidcSessionRequest(_jwt, _profile_id = undefined, _profile_selector = undefined) constructor
{
	jwt = _jwt;
	profileId = _profile_id;
	profileSelector = _profile_selector;
}

/**
 * @func ElementsJWK()
 * @param {String} _alg Algorithm (e.g. RS256)
 * @param {String} _kid Key id (unique to issuer)
 * @param {String} _kty Key type (e.g. RSA)
 * @param {String} _use The intended use (e.g. sig)
 * @param {String} _e Base64url encoded exponent
 * @param {String} _n Pub key modulus
 */
function ElementsJWK(_alg = undefined, _kid = undefined, _kty = undefined, _use = undefined, _e = undefined, _n = undefined) constructor
{
	alg = _alg;
	kid = _kid;
	kty = _kty;
	use = _use;
	e = _e;
	n = _n;
}

/**
 * @func ElementsOidcAuthScheme()
 * @param {String} _id The unique ID of the auth scheme.
 * @param {String} _issuer A unique name used to identify the scheme within the instance of Elements. When validating from an external source (e.g. Google or Apple SSO), must match the 'iss' property of the decoded JWT.
 * @param {Array[Struct.ElementsJWK]} _keys A set of JWKs containing the keys required to validate JWT signatures.
 * @param {String} _name The unique name of the auth scheme.
 * @param {String} _keys_url The URL for the JWK data. Will attempt to refresh keys if the kid cannot be found in the collection.
 * @param {String} _media_type The JWK format. Defaults to application/json
 */
function ElementsOidcAuthScheme(_id, _issuer, _keys, _name = undefined, _keys_url = undefined, _media_type = undefined) constructor
{
	id = _id;
	issuer = _issuer;
	keys = _keys;
	name = _name;
	keysUrl = _keys_url;
	mediaType = _media_type;
}

/**
 * @func ElementsCreateOrUpdateOidcAuthSchemeResponse()
 * @param {Struct.ElementsOidcAuthScheme} _scheme The full JSON response as described in AuthScheme
 */
function ElementsCreateOrUpdateOidcAuthSchemeResponse(_scheme = undefined) constructor
{
	scheme = _scheme;
}

/**
 * @func ElementsCreateOrUpdateOidcAuthSchemeRequest()
 * @param {String} _id The unique ID of the auth scheme.
 * @param {String} _issuer A unique name used to identify the scheme within the instance of Elements. When validating from an external source (e.g. Google or Apple SSO), must match the 'iss' property of the decoded JWT.
 * @param {Array[Struct.ElementsJWK]} _keys A set of JWKs containing the keys required to validate JWT signatures.
 * @param {String} _keys_url The URL for the JWK data. Will attempt to refresh keys if the kid cannot be found in the collection.
 * @param {String} _media_type The JWK format. Defaults to application/json
 */
function ElementsCreateOrUpdateOidcAuthSchemeRequest(_id, _issuer, _keys, _keys_url = undefined, _media_type = undefined) constructor
{
	id = _id;
	issuer = _issuer;
	keys = _keys;
	keysUrl = _keys_url;
	mediaType = _media_type;
}

/**
 * @func ElementsPaginationOidcAuthScheme()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsOidcAuthScheme]} _objects
 */
function ElementsPaginationOidcAuthScheme(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsVaultKey()
 * @param {String} _algorithm Specifies the private key encryption algorithm used to secure the vault. (one of: RSA_256 | RSA_384 | RSA_512)
 * @param {String} _public_key The public key portion of the vault key.
 * @param {String} _private_key The private key portion of the vault key.
 * @param {Real} _encrypted The flag to indicate if the key is encrypted or not.
 * @param {Struct} _encryption The Vault's encryption metadata. This is specific to the encryption type used.
 */
function ElementsVaultKey(_algorithm, _public_key, _private_key, _encrypted = undefined, _encryption = undefined) constructor
{
	algorithm = _algorithm;
	publicKey = _public_key;
	privateKey = _private_key;
	encrypted = _encrypted;
	encryption = _encryption;
}

/**
 * @func ElementsVault()
 * @param {String} _id The system assigned unique id of the vault.
 * @param {Struct.ElementsUser} _user The User associated with this Profile.
 * @param {String} _display_name The display name given to this vault.
 * @param {Struct.ElementsVaultKey} _key The Vault's key. The vault secures each vault with this key.
 */
function ElementsVault(_id, _user, _display_name, _key) constructor
{
	id = _id;
	user = _user;
	displayName = _display_name;
	key = _key;
}

/**
 * @func ElementsSmartContract()
 * @param {String} _id The Elements database id of the contract.
 * @param {String} _name The unique symbolic name of the smart contract.
 * @param {String} _display_name The name given to this contract for display purposes.
 * @param {Struct} _addresses The addresses of the contract from the blockchain. Depending on the network or protocol this may have several meanings. For example, this may be the script has for the Ethereum network.
 * @param {Struct.ElementsVault} _vault
 * @param {Struct} _metadata Any metadata for this contract.
 */
function ElementsSmartContract(_id, _name, _display_name, _addresses, _vault, _metadata = undefined) constructor
{
	id = _id;
	name = _name;
	displayName = _display_name;
	addresses = _addresses;
	vault = _vault;
	metadata = _metadata;
}

/**
 * @func ElementsSmartContractAddress()
 * @param {String} _address
 */
function ElementsSmartContractAddress(_address = undefined) constructor
{
	address = _address;
}

/**
 * @func ElementsCreateSmartContractRequest()
 * @param {String} _name The unique symbolic name of the smart contract.
 * @param {String} _display_name The name given to this contract for display purposes.
 * @param {Struct} _addresses The address of the contract from the blockchain. Depending on the network or protocol this may have several meanings and vary depending on the specific API or network.
 * @param {String} _vault_id The Elements database id of the wallet containing the default account to be used for contract related requests.
 * @param {Struct} _metadata Any metadata for this contract.
 */
function ElementsCreateSmartContractRequest(_name, _display_name, _addresses, _vault_id, _metadata = undefined) constructor
{
	name = _name;
	displayName = _display_name;
	addresses = _addresses;
	vaultId = _vault_id;
	metadata = _metadata;
}

/**
 * @func ElementsPaginationSmartContract()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsSmartContract]} _objects
 */
function ElementsPaginationSmartContract(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsUpdateSmartContractRequest()
 * @param {String} _name The unique symbolic name of the smart contract.
 * @param {String} _display_name The name given to this contract for display purposes.
 * @param {Struct} _addresses The address of the contract from the blockchain. Depending on the network or protocol this may have several meanings and vary depending on the specific API or network.
 * @param {String} _vault_id The Elements database id of the wallet containing the default account to be used for contract related requests.
 * @param {Struct} _metadata Any metadata for this contract.
 */
function ElementsUpdateSmartContractRequest(_name, _display_name, _addresses, _vault_id, _metadata = undefined) constructor
{
	name = _name;
	displayName = _display_name;
	addresses = _addresses;
	vaultId = _vault_id;
	metadata = _metadata;
}

/**
 * @func ElementsCreateVaultRequest()
 * @param {String} _user_id The elements-defined user ID to own the vault.
 * @param {String} _display_name A user-defined name for the vault. This is used simply for the user's reference and has no bearing  onthe vault's functionality.
 * @param {String} _passphrase The passphrase used to to encrypt the vault. If empty, then the vault will not be encrypted. Some configurations may opt to disallow encryption entirely.
 * @param {String} _algorithm The encryption algorithm used to secure the vault. Once crated, a vault will contains a private/public key pair which will be used to encrypt the wallets within the vault. (one of: RSA_256 | RSA_384 | RSA_512)
 */
function ElementsCreateVaultRequest(_user_id, _display_name, _passphrase = undefined, _algorithm = undefined) constructor
{
	userId = _user_id;
	displayName = _display_name;
	passphrase = _passphrase;
	algorithm = _algorithm;
}

/**
 * @func ElementsPaginationVault()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsVault]} _objects
 */
function ElementsPaginationVault(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsUpdateVaultRequest()
 * @param {String} _display_name A user-defined name for the vault. This is used simply for the user's reference and has no bearing  onthe vault's functionality.
 * @param {String} _user_id The elements-defined user ID to own the vault.
 * @param {String} _passphrase The current passphrase for the vault. If left null, no updates to the passphrase will be made. If not-null, then the new password must also not be null.
 * @param {String} _new_passphrase The updated passphrase for the vault. If left null, no updates to the passphrase will be made. If not-null, then the password must also not be null.
 */
function ElementsUpdateVaultRequest(_display_name, _user_id, _passphrase = undefined, _new_passphrase = undefined) constructor
{
	displayName = _display_name;
	userId = _user_id;
	passphrase = _passphrase;
	newPassphrase = _new_passphrase;
}

/**
 * @func ElementsWalletAccount()
 * @param {String} _address The Wallet Address - id public identity. Required.
 * @param {String} _private_key The Wallet Account - id private identity. May be null if the wallet is for receive only.
 * @param {Real} _encrypted Indicates if this identity is encrypted.
 */
function ElementsWalletAccount(_address, _private_key = undefined, _encrypted = undefined) constructor
{
	address = _address;
	privateKey = _private_key;
	encrypted = _encrypted;
}

/**
 * @func ElementsWallet()
 * @param {String} _id The system assigned unique id of the wallet.
 * @param {Struct.ElementsUser} _user The User associated with this Profile.
 * @param {Struct.ElementsVault} _vault
 * @param {String} _display_name The name given to this wallet.
 * @param {String} _api The protocol used wiht this wallet. (one of: NEO | ETHEREUM | SOLANA | FLOW | NEAR)
 * @param {Array[String]} _networks The networks associated with this wallet. (one of: NEO | NEO_TEST | ETHEREUM | ETHEREUM_TEST | BSC | BSC_TEST | POLYGON | POLYGON_TEST | SOLANA | SOLANA_TEST | FLOW | FLOW_TEST | NEAR | NEAR_TEST)
 * @param {Array[Struct.ElementsWalletAccount]} _accounts The list of account pairs included in this wallet.
 * @param {Real} _preferred_account The default account. Must not be larger than the count of identities.
 */
function ElementsWallet(_id, _user, _vault, _display_name, _api, _networks, _accounts, _preferred_account = undefined) constructor
{
	id = _id;
	user = _user;
	vault = _vault;
	displayName = _display_name;
	api = _api;
	networks = _networks;
	accounts = _accounts;
	preferredAccount = _preferred_account;
}

/**
 * @func ElementsCreateWalletRequestAccount()
 * @param {String} _address The Wallet Address - id public identity. Must be null for generated wallets.
 * @param {Real} _generate Flag which indicates if the account should be generated or imported.
 * @param {String} _private_key The Wallet Account - id private identity. May be null if the wallet is for receive only.
 */
function ElementsCreateWalletRequestAccount(_address, _generate = undefined, _private_key = undefined) constructor
{
	address = _address;
	generate = _generate;
	privateKey = _private_key;
}

/**
 * @func ElementsCreateWalletRequest()
 * @param {String} _display_name A user-defined name for the wallet. This is used simply for the user's reference and has no bearing  onthe wallet's functionality.
 * @param {String} _api The protocol of this wallet. Once set, this cannot be unset. (one of: NEO | ETHEREUM | SOLANA | FLOW | NEAR)
 * @param {Array[String]} _networks The networks associated with this wallet. All must support the Wallet's protocol. (one of: NEO | NEO_TEST | ETHEREUM | ETHEREUM_TEST | BSC | BSC_TEST | POLYGON | POLYGON_TEST | SOLANA | SOLANA_TEST | FLOW | FLOW_TEST | NEAR | NEAR_TEST)
 * @param {Array[Struct.ElementsCreateWalletRequestAccount]} _accounts
 * @param {Real} _preferred_account The default identity. Must not be larger than the count of identities.
 */
function ElementsCreateWalletRequest(_display_name, _api, _networks, _accounts, _preferred_account = undefined) constructor
{
	displayName = _display_name;
	api = _api;
	networks = _networks;
	accounts = _accounts;
	preferredAccount = _preferred_account;
}

/**
 * @func ElementsPaginationWallet()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsWallet]} _objects
 */
function ElementsPaginationWallet(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsUpdateWalletRequest()
 * @param {Array[String]} _networks The networks associated with this wallet. All must support the Wallet's protocol. (one of: NEO | NEO_TEST | ETHEREUM | ETHEREUM_TEST | BSC | BSC_TEST | POLYGON | POLYGON_TEST | SOLANA | SOLANA_TEST | FLOW | FLOW_TEST | NEAR | NEAR_TEST)
 * @param {String} _display_name The new display name of the wallet.
 * @param {Real} _preferred_account The default identity. Must not be larger than the count of identities.
 */
function ElementsUpdateWalletRequest(_networks, _display_name = undefined, _preferred_account = undefined) constructor
{
	networks = _networks;
	displayName = _display_name;
	preferredAccount = _preferred_account;
}

/**
 * @func ElementsDeployment()
 * @param {String} _id The unique ID of the deployment itself.
 * @param {String} _version The deployment version. Allows for overriding versions with new content.
 * @param {String} _revision The revision that this deployment points to.
 * @param {Struct.ElementsApplication} _application
 */
function ElementsDeployment(_id, _version, _revision, _application) constructor
{
	id = _id;
	version = _version;
	revision = _revision;
	application = _application;
}

/**
 * @func ElementsCreateDeploymentRequest()
 * @param {String} _version
 * @param {String} _revision
 */
function ElementsCreateDeploymentRequest(_version, _revision) constructor
{
	version = _version;
	revision = _revision;
}

/**
 * @func ElementsPaginationDeployment()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsDeployment]} _objects
 */
function ElementsPaginationDeployment(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsUpdateDeploymentRequest()
 * @param {String} _revision
 */
function ElementsUpdateDeploymentRequest(_revision) constructor
{
	revision = _revision;
}

/**
 * @func ElementsCodegenRequest()
 * @param {String} _element_spec_url The URL for the Element OpenApi spec. Usually /app/rest/elementName/openapi.json
 * @param {String} _language The target language that you want to generate the code to.
 * @param {String} _package_name The package name to set the generated code to. E.g. com.mycompany.mygame.Elements
 * @param {String} _options Any additional options that you want to pass to the generator
 */
function ElementsCodegenRequest(_element_spec_url = undefined, _language = undefined, _package_name = undefined, _options = undefined) constructor
{
	elementSpecUrl = _element_spec_url;
	language = _language;
	packageName = _package_name;
	options = _options;
}

/**
 * @func ElementsFilterRegistration()
 * @param {Array[String]} _servlet_name_mappings
 * @param {Array[String]} _url_pattern_mappings
 * @param {String} _name
 * @param {String} _class_name
 * @param {Struct} _init_parameters
 */
function ElementsFilterRegistration(_servlet_name_mappings = undefined, _url_pattern_mappings = undefined, _name = undefined, _class_name = undefined, _init_parameters = undefined) constructor
{
	servletNameMappings = _servlet_name_mappings;
	urlPatternMappings = _url_pattern_mappings;
	name = _name;
	className = _class_name;
	initParameters = _init_parameters;
}

/**
 * @func ElementsTaglibDescriptor()
 * @param {String} _taglib_uri
 * @param {String} _taglib_location
 */
function ElementsTaglibDescriptor(_taglib_uri = undefined, _taglib_location = undefined) constructor
{
	taglibURI = _taglib_uri;
	taglibLocation = _taglib_location;
}

/**
 * @func ElementsJspPropertyGroupDescriptor()
 * @param {String} _buffer
 * @param {Array[String]} _url_patterns
 * @param {String} _el_ignored
 * @param {String} _is_xml
 * @param {String} _error_on_el_not_found
 * @param {String} _page_encoding
 * @param {String} _scripting_invalid
 * @param {Array[String]} _include_preludes
 * @param {Array[String]} _include_codas
 * @param {String} _default_content_type
 * @param {String} _trim_directive_whitespaces
 * @param {String} _error_on_undeclared_namespace
 * @param {String} _deferred_syntax_allowed_as_literal
 */
function ElementsJspPropertyGroupDescriptor(_buffer = undefined, _url_patterns = undefined, _el_ignored = undefined, _is_xml = undefined, _error_on_el_not_found = undefined, _page_encoding = undefined, _scripting_invalid = undefined, _include_preludes = undefined, _include_codas = undefined, _default_content_type = undefined, _trim_directive_whitespaces = undefined, _error_on_undeclared_namespace = undefined, _deferred_syntax_allowed_as_literal = undefined) constructor
{
	buffer = _buffer;
	urlPatterns = _url_patterns;
	elIgnored = _el_ignored;
	isXml = _is_xml;
	errorOnELNotFound = _error_on_el_not_found;
	pageEncoding = _page_encoding;
	scriptingInvalid = _scripting_invalid;
	includePreludes = _include_preludes;
	includeCodas = _include_codas;
	defaultContentType = _default_content_type;
	trimDirectiveWhitespaces = _trim_directive_whitespaces;
	errorOnUndeclaredNamespace = _error_on_undeclared_namespace;
	deferredSyntaxAllowedAsLiteral = _deferred_syntax_allowed_as_literal;
}

/**
 * @func ElementsJspConfigDescriptor()
 * @param {Array[Struct.ElementsTaglibDescriptor]} _taglibs
 * @param {Array[Struct.ElementsJspPropertyGroupDescriptor]} _jsp_property_groups
 */
function ElementsJspConfigDescriptor(_taglibs = undefined, _jsp_property_groups = undefined) constructor
{
	taglibs = _taglibs;
	jspPropertyGroups = _jsp_property_groups;
}

/**
 * @func ElementsSessionCookieConfig()
 * @param {String} _path
 * @param {String} _domain
 * @param {String} _name
 * @param {Struct} _attributes
 * @param {String} _comment
 * @param {Real} _http_only
 * @param {Real} _secure
 * @param {Real} _max_age
 */
function ElementsSessionCookieConfig(_path = undefined, _domain = undefined, _name = undefined, _attributes = undefined, _comment = undefined, _http_only = undefined, _secure = undefined, _max_age = undefined) constructor
{
	path = _path;
	domain = _domain;
	name = _name;
	attributes = _attributes;
	comment = _comment;
	httpOnly = _http_only;
	secure = _secure;
	maxAge = _max_age;
}

/**
 * @func ElementsServletContext()
 * @param {Struct} _class_loader
 * @param {Real} _major_version
 * @param {Real} _minor_version
 * @param {String} _context_path
 * @param {String} _server_info
 * @param {Struct} _attribute_names
 * @param {String} _servlet_context_name
 * @param {Struct} _filter_registrations
 * @param {Struct.ElementsSessionCookieConfig} _session_cookie_config
 * @param {Struct.ElementsJspConfigDescriptor} _jsp_config_descriptor
 * @param {String} _virtual_server_name
 * @param {Real} _session_timeout
 * @param {Struct} _init_parameter_names
 * @param {Real} _effective_major_version
 * @param {Real} _effective_minor_version
 * @param {Struct} _servlet_registrations
 * @param {Array[String]} _session_tracking_modes  (one of: COOKIE | URL | SSL)
 * @param {Array[String]} _default_session_tracking_modes  (one of: COOKIE | URL | SSL)
 * @param {String} _request_character_encoding
 * @param {String} _response_character_encoding
 * @param {Array[String]} _effective_session_tracking_modes  (one of: COOKIE | URL | SSL)
 */
function ElementsServletContext(_class_loader = undefined, _major_version = undefined, _minor_version = undefined, _context_path = undefined, _server_info = undefined, _attribute_names = undefined, _servlet_context_name = undefined, _filter_registrations = undefined, _session_cookie_config = undefined, _jsp_config_descriptor = undefined, _virtual_server_name = undefined, _session_timeout = undefined, _init_parameter_names = undefined, _effective_major_version = undefined, _effective_minor_version = undefined, _servlet_registrations = undefined, _session_tracking_modes = undefined, _default_session_tracking_modes = undefined, _request_character_encoding = undefined, _response_character_encoding = undefined, _effective_session_tracking_modes = undefined) constructor
{
	classLoader = _class_loader;
	majorVersion = _major_version;
	minorVersion = _minor_version;
	contextPath = _context_path;
	serverInfo = _server_info;
	attributeNames = _attribute_names;
	servletContextName = _servlet_context_name;
	filterRegistrations = _filter_registrations;
	sessionCookieConfig = _session_cookie_config;
	jspConfigDescriptor = _jsp_config_descriptor;
	virtualServerName = _virtual_server_name;
	sessionTimeout = _session_timeout;
	initParameterNames = _init_parameter_names;
	effectiveMajorVersion = _effective_major_version;
	effectiveMinorVersion = _effective_minor_version;
	servletRegistrations = _servlet_registrations;
	sessionTrackingModes = _session_tracking_modes;
	defaultSessionTrackingModes = _default_session_tracking_modes;
	requestCharacterEncoding = _request_character_encoding;
	responseCharacterEncoding = _response_character_encoding;
	effectiveSessionTrackingModes = _effective_session_tracking_modes;
}

/**
 * @func ElementsServletConfig()
 * @param {String} _servlet_name
 * @param {Struct.ElementsServletContext} _servlet_context
 * @param {Struct} _init_parameter_names
 */
function ElementsServletConfig(_servlet_name = undefined, _servlet_context = undefined, _init_parameter_names = undefined) constructor
{
	servletName = _servlet_name;
	servletContext = _servlet_context;
	initParameterNames = _init_parameter_names;
}

/**
 * @func ElementsServletRegistration()
 * @param {Array[String]} _mappings
 * @param {String} _run_as_role
 * @param {String} _name
 * @param {String} _class_name
 * @param {Struct} _init_parameters
 */
function ElementsServletRegistration(_mappings = undefined, _run_as_role = undefined, _name = undefined, _class_name = undefined, _init_parameters = undefined) constructor
{
	mappings = _mappings;
	runAsRole = _run_as_role;
	name = _name;
	className = _class_name;
	initParameters = _init_parameters;
}

/**
 * @func ElementsPaginationProfile()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsProfile]} _objects
 */
function ElementsPaginationProfile(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsCreateFollowerRequest()
 * @param {String} _followed_id The profile id which to follow.
 */
function ElementsCreateFollowerRequest(_followed_id) constructor
{
	followedId = _followed_id;
}

/**
 * @func ElementsFriend()
 * @param {String} _id The unique ID of the friendship.
 * @param {Struct.ElementsUser} _user The User associated with this Profile.
 * @param {String} _friendship The friendship type. (one of: NONE | OUTGOING | INCOMING | MUTUAL)
 * @param {Array[Struct.ElementsProfile]} _profiles The profiles which are associated with the friend user.
 */
function ElementsFriend(_id = undefined, _user = undefined, _friendship = undefined, _profiles = undefined) constructor
{
	id = _id;
	user = _user;
	friendship = _friendship;
	profiles = _profiles;
}

/**
 * @func ElementsPaginationFriend()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsFriend]} _objects
 */
function ElementsPaginationFriend(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsCreateItemRequest()
 * @param {String} _name
 * @param {String} _display_name
 * @param {String} _description
 * @param {String} _category  (one of: FUNGIBLE | DISTINCT)
 * @param {Array[String]} _tags
 * @param {String} _metadata_spec_id
 * @param {Struct} _metadata
 * @param {Real} _public_visible
 * @param {String} _metadata_spec
 */
function ElementsCreateItemRequest(_name, _display_name, _description, _category, _tags = undefined, _metadata_spec_id = undefined, _metadata = undefined, _public_visible = undefined, _metadata_spec = undefined) constructor
{
	name = _name;
	displayName = _display_name;
	description = _description;
	category = _category;
	tags = _tags;
	metadataSpecId = _metadata_spec_id;
	metadata = _metadata;
	publicVisible = _public_visible;
	metadataSpec = _metadata_spec;
}

/**
 * @func ElementsPaginationItem()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsItem]} _objects
 */
function ElementsPaginationItem(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsUpdateItemRequest()
 * @param {String} _name
 * @param {String} _display_name
 * @param {String} _description
 * @param {Array[String]} _tags
 * @param {Struct.ElementsMetadataSpec} _metadata_spec Represents a spec for metadata.
 * @param {Struct} _metadata
 * @param {Real} _public_visible
 */
function ElementsUpdateItemRequest(_name, _display_name, _description, _tags = undefined, _metadata_spec = undefined, _metadata = undefined, _public_visible = undefined) constructor
{
	name = _name;
	displayName = _display_name;
	description = _description;
	tags = _tags;
	metadataSpec = _metadata_spec;
	metadata = _metadata;
	publicVisible = _public_visible;
}

/**
 * @func ElementsCreateGooglePlayIapReceipt()
 * @param {String} _package_name The package name of the app. Note that this may be different from the applicationId/uniqueIdentifier which is why it should be provided with the request.
 * @param {String} _product_id The product id purchased by the user, e.g. `com.namazustudios.example_app.pack_10_coins`.
 * @param {String} _purchase_token The token issued to the user upon successful Google Play purchase transaction.
 */
function ElementsCreateGooglePlayIapReceipt(_package_name, _product_id, _purchase_token) constructor
{
	packageName = _package_name;
	productId = _product_id;
	purchaseToken = _purchase_token;
}

/**
 * @func ElementsBuildIndexRequest()
 * @param {Real} _plan Set to true to plan the index building.
 * @param {Array[String]} _to_index Set to true to perform the index building. (one of: DISTINCT_INVENTORY_ITEM | METADATA)
 */
function ElementsBuildIndexRequest(_plan = undefined, _to_index = undefined) constructor
{
	plan = _plan;
	toIndex = _to_index;
}

/**
 * @func ElementsIndexMetadataObject()
 * @param {Struct} _identifier
 */
function ElementsIndexMetadataObject(_identifier = undefined) constructor
{
	identifier = _identifier;
}

/**
 * @func ElementsIndexPlanStepObject()
 * @param {String} _description
 * @param {String} _operation  (one of: CREATE | LEAVE_AS_IS | REPLACE | DELETE)
 * @param {Struct.ElementsIndexMetadataObject} _index_metadata
 */
function ElementsIndexPlanStepObject(_description = undefined, _operation = undefined, _index_metadata = undefined) constructor
{
	description = _description;
	operation = _operation;
	indexMetadata = _index_metadata;
}

/**
 * @func ElementsIndexPlanObject()
 * @param {String} _id
 * @param {String} _state  (one of: READY | PROCESSING | APPLIED)
 * @param {Struct.ElementsIndexPlanStepObject} _steps
 */
function ElementsIndexPlanObject(_id = undefined, _state = undefined, _steps = undefined) constructor
{
	id = _id;
	state = _state;
	steps = _steps;
}

/**
 * @func ElementsPaginationIndexPlanObject()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsIndexPlanObject]} _objects
 */
function ElementsPaginationIndexPlanObject(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsInventoryItem()
 * @param {String} _id The unique ID of the inventory item itself.
 * @param {Struct.ElementsUser} _user The User associated with this Profile.
 * @param {Struct.ElementsItem} _item The Item to be issued upon redemption.
 * @param {Real} _quantity The quantity of the Item in inventory
 * @param {Real} _priority The priority of this Item grouping in inventory (for stacked/packaged inventory support)
 */
function ElementsInventoryItem(_id, _user, _item, _quantity, _priority) constructor
{
	id = _id;
	user = _user;
	item = _item;
	quantity = _quantity;
	priority = _priority;
}

/**
 * @func ElementsAdvancedInventoryItemQuantityAdjustment()
 * @param {String} _user_id The User whose inventory to modify.
 * @param {Real} _quantity_delta The delta to be applied to the inventory item quantity (positive or negative)
 * @param {Real} _priority The priority slot for the item.
 */
function ElementsAdvancedInventoryItemQuantityAdjustment(_user_id, _quantity_delta, _priority = undefined) constructor
{
	userId = _user_id;
	quantityDelta = _quantity_delta;
	priority = _priority;
}

/**
 * @func ElementsCreateAdvancedInventoryItemRequest()
 * @param {String} _user_id The User ID
 * @param {String} _item_id The item to reference.
 * @param {Real} _quantity The quantity of the Item in inventory
 * @param {Real} _priority The priority slot for the item.
 */
function ElementsCreateAdvancedInventoryItemRequest(_user_id, _item_id, _quantity = undefined, _priority = undefined) constructor
{
	userId = _user_id;
	itemId = _item_id;
	quantity = _quantity;
	priority = _priority;
}

/**
 * @func ElementsPaginationInventoryItem()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsInventoryItem]} _objects
 */
function ElementsPaginationInventoryItem(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsUpdateInventoryItemRequest()
 * @param {Real} _quantity The quantity of the Item in inventory
 */
function ElementsUpdateInventoryItemRequest(_quantity = undefined) constructor
{
	quantity = _quantity;
}

/**
 * @func ElementsDistinctInventoryItem()
 * @param {String} _id The unique ID of the inventory item itself.
 * @param {Struct.ElementsItem} _item The Item to be issued upon redemption.
 * @param {Struct.ElementsUser} _user The User associated with this Profile.
 * @param {Struct.ElementsProfile} _profile
 * @param {Struct} _metadata
 */
function ElementsDistinctInventoryItem(_id, _item, _user, _profile = undefined, _metadata = undefined) constructor
{
	id = _id;
	item = _item;
	user = _user;
	profile = _profile;
	metadata = _metadata;
}

/**
 * @func ElementsCreateDistinctInventoryItemRequest()
 * @param {String} _item_id The digital goods item id.
 * @param {String} _user_id The id of the User owning this inventory item id.
 * @param {String} _profile_id The the profileid of hte Profile owning this inventory item.
 * @param {Struct} _metadata
 */
function ElementsCreateDistinctInventoryItemRequest(_item_id, _user_id = undefined, _profile_id = undefined, _metadata = undefined) constructor
{
	itemId = _item_id;
	userId = _user_id;
	profileId = _profile_id;
	metadata = _metadata;
}

/**
 * @func ElementsPaginationDistinctInventoryItem()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsDistinctInventoryItem]} _objects
 */
function ElementsPaginationDistinctInventoryItem(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsUpdateDistinctInventoryItemRequest()
 * @param {String} _user_id The id of the User owning this inventory item id.
 * @param {String} _profile_id The the profile id of hte Profile owning this inventory item.
 * @param {Struct} _metadata
 */
function ElementsUpdateDistinctInventoryItemRequest(_user_id = undefined, _profile_id = undefined, _metadata = undefined) constructor
{
	userId = _user_id;
	profileId = _profile_id;
	metadata = _metadata;
}

/**
 * @func ElementsSimpleInventoryItemQuantityAdjustment()
 * @param {String} _user_id The User whose inventory to modify.
 * @param {Real} _quantity_delta The delta to be applied to the inventory item quantity (positive or negative)
 */
function ElementsSimpleInventoryItemQuantityAdjustment(_user_id, _quantity_delta) constructor
{
	userId = _user_id;
	quantityDelta = _quantity_delta;
}

/**
 * @func ElementsCreateSimpleInventoryItemRequest()
 * @param {String} _user_id The User ID
 * @param {String} _item_id The item to reference.
 * @param {Real} _quantity The quantity of the Item in inventory
 */
function ElementsCreateSimpleInventoryItemRequest(_user_id, _item_id, _quantity = undefined) constructor
{
	userId = _user_id;
	itemId = _item_id;
	quantity = _quantity;
}

/**
 * @func ElementsPhoneMatchedInvitation()
 * @param {String} _phone_number Phone number
 * @param {Array[String]} _profile_ids The list of profile Ids that phone was matched
 */
function ElementsPhoneMatchedInvitation(_phone_number = undefined, _profile_ids = undefined) constructor
{
	phoneNumber = _phone_number;
	profileIds = _profile_ids;
}

/**
 * @func ElementsInviteViaPhonesResponse()
 * @param {Array[Struct.ElementsPhoneMatchedInvitation]} _matched The list of objects representing matched phone numbers
 */
function ElementsInviteViaPhonesResponse(_matched = undefined) constructor
{
	matched = _matched;
}

/**
 * @func ElementsInviteViaPhonesRequest()
 * @param {Array[String]} _phone_numbers The list of phone numbers
 */
function ElementsInviteViaPhonesRequest(_phone_numbers = undefined) constructor
{
	phoneNumbers = _phone_numbers;
}

/**
 * @func ElementsSubjects()
 * @param {Array[Struct.ElementsUser]} _users Users which may perform the operations.
 * @param {Array[Struct.ElementsProfile]} _profiles Profiles, which owners may perform the operations.
 * @param {Real} _wildcard Flag to check who may perform the operations. True if all users may access the object.
 */
function ElementsSubjects(_users, _profiles, _wildcard = undefined) constructor
{
	users = _users;
	profiles = _profiles;
	wildcard = _wildcard;
}

/**
 * @func ElementsAccessPermissions()
 * @param {Struct.ElementsSubjects} _read Subjects allowed to delete
 * @param {Struct.ElementsSubjects} _write Subjects allowed to delete
 * @param {Struct.ElementsSubjects} _delete Subjects allowed to delete
 */
function ElementsAccessPermissions(_read, _write, _delete) constructor
{
	read = _read;
	write = _write;
	self[$ "delete"] = _delete;
}

/**
 * @func ElementsLargeObject()
 * @param {String} _id The unique ID of the LargeObject.
 * @param {String} _path The path to the file in the underlying bucket.
 * @param {Struct.ElementsAccessPermissions} _access_permissions Permission associated with LargeObject.
 * @param {String} _url The URL where the binary contents of the LargeObject may be read. May be null, since Path param or Id is pointer for object.
 * @param {String} _mime_type The MIME type of the LargeObject.
 * @param {String} _state Current state of large object (one of: EMPTY | UPLOADED)
 * @param {String} _last_modified Date of last modification
 */
function ElementsLargeObject(_id, _path, _access_permissions, _url = undefined, _mime_type = undefined, _state = undefined, _last_modified = undefined) constructor
{
	id = _id;
	path = _path;
	accessPermissions = _access_permissions;
	url = _url;
	mimeType = _mime_type;
	state = _state;
	lastModified = _last_modified;
}

/**
 * @func ElementsContentDisposition()
 * @param {String} _type
 * @param {Struct} _parameters
 * @param {String} _file_name
 * @param {String} _creation_date
 * @param {String} _modification_date
 * @param {String} _read_date
 * @param {Real} _size
 */
function ElementsContentDisposition(_type = undefined, _parameters = undefined, _file_name = undefined, _creation_date = undefined, _modification_date = undefined, _read_date = undefined, _size = undefined) constructor
{
	type = _type;
	parameters = _parameters;
	fileName = _file_name;
	creationDate = _creation_date;
	modificationDate = _modification_date;
	readDate = _read_date;
	size = _size;
}

/**
 * @func ElementsMediaType()
 * @param {String} _type
 * @param {String} _subtype
 * @param {Struct} _parameters
 * @param {Real} _wildcard_type
 * @param {Real} _wildcard_subtype
 */
function ElementsMediaType(_type = undefined, _subtype = undefined, _parameters = undefined, _wildcard_type = undefined, _wildcard_subtype = undefined) constructor
{
	type = _type;
	subtype = _subtype;
	parameters = _parameters;
	wildcardType = _wildcard_type;
	wildcardSubtype = _wildcard_subtype;
}

/**
 * @func ElementsMultiPart()
 * @param {Struct.ElementsContentDisposition} _content_disposition
 * @param {Struct} _entity
 * @param {Struct} _headers
 * @param {Struct.ElementsMediaType} _media_type
 * @param {Struct} _message_body_workers
 * @param {Struct.ElementsMultiPart} _parent
 * @param {Struct} _providers
 * @param {Array[Struct.ElementsBodyPart]} _body_parts
 * @param {Struct} _parameterized_headers
 */
function ElementsMultiPart(_content_disposition = undefined, _entity = undefined, _headers = undefined, _media_type = undefined, _message_body_workers = undefined, _parent = undefined, _providers = undefined, _body_parts = undefined, _parameterized_headers = undefined) constructor
{
	contentDisposition = _content_disposition;
	entity = _entity;
	headers = _headers;
	mediaType = _media_type;
	messageBodyWorkers = _message_body_workers;
	parent = _parent;
	providers = _providers;
	bodyParts = _body_parts;
	parameterizedHeaders = _parameterized_headers;
}

/**
 * @func ElementsBodyPart()
 * @param {Struct.ElementsContentDisposition} _content_disposition
 * @param {Struct} _entity
 * @param {Struct} _headers
 * @param {Struct.ElementsMediaType} _media_type
 * @param {Struct} _message_body_workers
 * @param {Struct.ElementsMultiPart} _parent
 * @param {Struct} _providers
 * @param {Struct} _parameterized_headers
 */
function ElementsBodyPart(_content_disposition = undefined, _entity = undefined, _headers = undefined, _media_type = undefined, _message_body_workers = undefined, _parent = undefined, _providers = undefined, _parameterized_headers = undefined) constructor
{
	contentDisposition = _content_disposition;
	entity = _entity;
	headers = _headers;
	mediaType = _media_type;
	messageBodyWorkers = _message_body_workers;
	parent = _parent;
	providers = _providers;
	parameterizedHeaders = _parameterized_headers;
}

/**
 * @func ElementsFormDataContentDisposition()
 * @param {String} _type
 * @param {Struct} _parameters
 * @param {String} _file_name
 * @param {String} _creation_date
 * @param {String} _modification_date
 * @param {String} _read_date
 * @param {Real} _size
 * @param {String} _name
 */
function ElementsFormDataContentDisposition(_type = undefined, _parameters = undefined, _file_name = undefined, _creation_date = undefined, _modification_date = undefined, _read_date = undefined, _size = undefined, _name = undefined) constructor
{
	type = _type;
	parameters = _parameters;
	fileName = _file_name;
	creationDate = _creation_date;
	modificationDate = _modification_date;
	readDate = _read_date;
	size = _size;
	name = _name;
}

/**
 * @func ElementsFormDataBodyPart()
 * @param {Struct.ElementsContentDisposition} _content_disposition
 * @param {Struct} _entity
 * @param {Struct} _headers
 * @param {Struct.ElementsMediaType} _media_type
 * @param {Struct} _message_body_workers
 * @param {Struct.ElementsMultiPart} _parent
 * @param {Struct} _providers
 * @param {String} _name
 * @param {String} _value
 * @param {Struct} _content
 * @param {String} _file_name
 * @param {Real} _simple
 * @param {Struct.ElementsFormDataContentDisposition} _form_data_content_disposition
 * @param {Struct} _parameterized_headers
 */
function ElementsFormDataBodyPart(_content_disposition = undefined, _entity = undefined, _headers = undefined, _media_type = undefined, _message_body_workers = undefined, _parent = undefined, _providers = undefined, _name = undefined, _value = undefined, _content = undefined, _file_name = undefined, _simple = undefined, _form_data_content_disposition = undefined, _parameterized_headers = undefined) constructor
{
	contentDisposition = _content_disposition;
	entity = _entity;
	headers = _headers;
	mediaType = _media_type;
	messageBodyWorkers = _message_body_workers;
	parent = _parent;
	providers = _providers;
	name = _name;
	value = _value;
	content = _content;
	fileName = _file_name;
	simple = _simple;
	formDataContentDisposition = _form_data_content_disposition;
	parameterizedHeaders = _parameterized_headers;
}

/**
 * @func ElementsMultivaluedMapStringParameterizedHeader()
 * @param {Real} _empty
 */
function ElementsMultivaluedMapStringParameterizedHeader(_empty = undefined) constructor
{
	empty = _empty;
}

/**
 * @func ElementsMultivaluedMapStringString()
 * @param {Real} _empty
 */
function ElementsMultivaluedMapStringString(_empty = undefined) constructor
{
	empty = _empty;
}

/**
 * @func ElementsParameterizedHeader()
 * @param {String} _value
 * @param {Struct} _parameters
 */
function ElementsParameterizedHeader(_value = undefined, _parameters = undefined) constructor
{
	value = _value;
	parameters = _parameters;
}

/**
 * @func ElementsSubjectRequest()
 * @param {Array[String]} _user_ids A List of all UserIds which can operate against the LargeObject.
 * @param {Array[String]} _profile_ids A List of all ProfileIds which can operate against the LargeObject.
 * @param {Real} _wildcard Flag to check who may perform the operation. If true, all anonymous users may perform the operation.
 */
function ElementsSubjectRequest(_user_ids, _profile_ids, _wildcard = undefined) constructor
{
	userIds = _user_ids;
	profileIds = _profile_ids;
	wildcard = _wildcard;
}

/**
 * @func ElementsCreateLargeObjectRequest()
 * @param {String} _mime_type The MIME type associated with the object.
 * @param {Struct.ElementsSubjectRequest} _read Specifies the Subjects which can delete the LargeObject.
 * @param {Struct.ElementsSubjectRequest} _write Specifies the Subjects which can delete the LargeObject.
 * @param {Struct.ElementsSubjectRequest} _delete Specifies the Subjects which can delete the LargeObject.
 */
function ElementsCreateLargeObjectRequest(_mime_type, _read, _write, _delete) constructor
{
	mimeType = _mime_type;
	read = _read;
	write = _write;
	self[$ "delete"] = _delete;
}

/**
 * @func ElementsCreateLargeObjectFromUrlRequest()
 * @param {String} _mime_type The MIME type associated with the object.
 * @param {Struct.ElementsSubjectRequest} _read Specifies the Subjects which can delete the LargeObject.
 * @param {Struct.ElementsSubjectRequest} _write Specifies the Subjects which can delete the LargeObject.
 * @param {Struct.ElementsSubjectRequest} _delete Specifies the Subjects which can delete the LargeObject.
 * @param {String} _file_url List with image URLs
 */
function ElementsCreateLargeObjectFromUrlRequest(_mime_type, _read, _write, _delete, _file_url) constructor
{
	mimeType = _mime_type;
	read = _read;
	write = _write;
	self[$ "delete"] = _delete;
	fileUrl = _file_url;
}

/**
 * @func ElementsUpdateLargeObjectRequest()
 * @param {String} _mime_type The MIME type associated with the object.
 * @param {Struct.ElementsSubjectRequest} _read Specifies the Subjects which can delete the LargeObject.
 * @param {Struct.ElementsSubjectRequest} _write Specifies the Subjects which can delete the LargeObject.
 * @param {Struct.ElementsSubjectRequest} _delete Specifies the Subjects which can delete the LargeObject.
 */
function ElementsUpdateLargeObjectRequest(_mime_type, _read, _write, _delete) constructor
{
	mimeType = _mime_type;
	read = _read;
	write = _write;
	self[$ "delete"] = _delete;
}

/**
 * @func ElementsLeaderboard()
 * @param {String} _name The name of the leaderboard.  This must be unique across all leaderboards.
 * @param {String} _time_strategy_type The time strategy for the leaderboard. Current options are ALL_TIME and EPOCHAL. (one of: ALL_TIME | EPOCHAL)
 * @param {String} _score_strategy_type The score strategy for the leaderboard. Current options are OVERWRITE_IF_GREATER and ACCUMULATE. (one of: OVERWRITE_IF_GREATER | ACCUMULATE)
 * @param {String} _title The user-presentable name or title for for the leaderboard.
 * @param {String} _score_units The units-of measure for the score type of the leaderboard.
 * @param {String} _id
 * @param {Real} _first_epoch_timestamp The time at which the leaderboard epoch intervals should begin (in ms). If null, then the leaderboard is all-time and not epochal. During creation, if this value is provided, then epochInterval must also be provided.
 * @param {Real} _epoch_interval The duration for a leaderboard epoch interval (in ms). If null, then the leaderboard is all-time and not epochal. During creation, if this value is provided, then firstEpochTimestamp must also be provided.
 */
function ElementsLeaderboard(_name, _time_strategy_type, _score_strategy_type, _title, _score_units, _id = undefined, _first_epoch_timestamp = undefined, _epoch_interval = undefined) constructor
{
	name = _name;
	timeStrategyType = _time_strategy_type;
	scoreStrategyType = _score_strategy_type;
	title = _title;
	scoreUnits = _score_units;
	id = _id;
	firstEpochTimestamp = _first_epoch_timestamp;
	epochInterval = _epoch_interval;
}

/**
 * @func ElementsPaginationLeaderboard()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsLeaderboard]} _objects
 */
function ElementsPaginationLeaderboard(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsScore()
 * @param {String} _id The ID of the Score
 * @param {Struct.ElementsProfile} _profile
 * @param {Real} _creation_timestamp The time at which the score was created on the server.
 * @param {Real} _leaderboard_epoch The epoch to which the score belongs for the associated leaderboard. By convention, if the leaderboard is all-time, this value will be set to zero.
 * @param {Real} _point_value The point value of the score.
 * @param {String} _score_units The the units of measure for the points.  For example, if the points in the game were called "coins" instead of "points" this would be used to designate as such in the UI.
 */
function ElementsScore(_id, _profile, _creation_timestamp, _leaderboard_epoch, _point_value = undefined, _score_units = undefined) constructor
{
	id = _id;
	profile = _profile;
	creationTimestamp = _creation_timestamp;
	leaderboardEpoch = _leaderboard_epoch;
	pointValue = _point_value;
	scoreUnits = _score_units;
}

/**
 * @func ElementsRank()
 * @param {Struct.ElementsScore} _score
 * @param {Real} _position The position of the associated score in the result set.
 */
function ElementsRank(_score, _position = undefined) constructor
{
	self[$ "score"] = _score;
	position = _position;
}

/**
 * @func ElementsPaginationRank()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsRank]} _objects
 */
function ElementsPaginationRank(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsRankRow()
 * @param {String} _profile_id The profile ID of the user who holds this rank.
 * @param {String} _profile_display_name The profile display name of the user who holds this rank.
 * @param {String} _profile_image_url The profile image url of the user who holds this rank.
 * @param {Real} _last_login The last login.
 * @param {String} _id The ID of the Score
 * @param {Real} _position The position of the associated score in the result set.
 * @param {Real} _point_value The point value of the score.
 * @param {String} _score_units The the units of measure for the points.  For example, if the points in the game were called "coins" instead of "points" this would be used to designate as such in the UI.
 * @param {Real} _creation_timestamp The time at which the score was created on the server.
 * @param {Real} _leaderboard_epoch The epoch to which the score belongs for the associated leaderboard. By convention, if the leaderboard is all-time, this value will be set to zero.
 */
function ElementsRankRow(_profile_id, _profile_display_name, _profile_image_url, _last_login, _id = undefined, _position = undefined, _point_value = undefined, _score_units = undefined, _creation_timestamp = undefined, _leaderboard_epoch = undefined) constructor
{
	profileId = _profile_id;
	profileDisplayName = _profile_display_name;
	profileImageUrl = _profile_image_url;
	lastLogin = _last_login;
	id = _id;
	position = _position;
	pointValue = _point_value;
	scoreUnits = _score_units;
	creationTimestamp = _creation_timestamp;
	leaderboardEpoch = _leaderboard_epoch;
}

/**
 * @func ElementsTabulationRankRow()
 * @param {Array[Struct.ElementsRankRow]} _rows
 */
function ElementsTabulationRankRow(_rows) constructor
{
	rows = _rows;
}

/**
 * @func ElementsMatch()
 * @param {String} _scheme The scheme to use when matching with other players.
 * @param {Struct.ElementsProfile} _player
 * @param {String} _id The unique ID of the match.
 * @param {String} _scope An optional scope for the match.  For example, if the match were part of a tournament, it could be scoped to the unique ID of the tournament.
 * @param {Struct.ElementsProfile} _opponent
 * @param {Real} _last_updated_timestamp The time of the last modification of the match.
 * @param {String} _game_id The system-assigned game ID of the match.  Null until the match is successfully made.
 * @param {Struct} _metadata Additional arbitrary metadata that is attached to the match.
 */
function ElementsMatch(_scheme, _player, _id = undefined, _scope = undefined, _opponent = undefined, _last_updated_timestamp = undefined, _game_id = undefined, _metadata = undefined) constructor
{
	scheme = _scheme;
	player = _player;
	id = _id;
	scope = _scope;
	opponent = _opponent;
	lastUpdatedTimestamp = _last_updated_timestamp;
	gameId = _game_id;
	metadata = _metadata;
}

/**
 * @func ElementsPaginationMatch()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsMatch]} _objects
 */
function ElementsPaginationMatch(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsMetadata()
 * @param {String} _id The metadata object's database assigned unique ID.
 * @param {String} _name A unique name for the metadata object.
 * @param {Struct} _metadata An object containing the metadata payload as key-value pairs.
 * @param {String} _access_level The minimum level of access required to view this metadata. (one of: UNPRIVILEGED | USER | SUPERUSER)
 * @param {Struct.ElementsMetadataSpec} _metadata_spec Represents a spec for metadata.
 */
function ElementsMetadata(_id, _name, _metadata, _access_level, _metadata_spec = undefined) constructor
{
	id = _id;
	name = _name;
	metadata = _metadata;
	accessLevel = _access_level;
	metadataSpec = _metadata_spec;
}

/**
 * @func ElementsCreateMetadataRequest()
 * @param {String} _name A unique name for the metadata object.
 * @param {Struct} _metadata An object containing the metadata payload as key-value pairs.
 * @param {Struct.ElementsMetadataSpec} _metadata_spec Represents a spec for metadata.
 * @param {String} _access_level The minimum level of access required to view this metadata. (one of: UNPRIVILEGED | USER | SUPERUSER)
 */
function ElementsCreateMetadataRequest(_name, _metadata = undefined, _metadata_spec = undefined, _access_level = undefined) constructor
{
	name = _name;
	metadata = _metadata;
	metadataSpec = _metadata_spec;
	accessLevel = _access_level;
}

/**
 * @func ElementsPaginationMetadata()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsMetadata]} _objects
 */
function ElementsPaginationMetadata(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsUpdateMetadataRequest()
 * @param {Struct} _metadata An object containing the metadata payload as key-value pairs.
 * @param {Struct.ElementsMetadataSpec} _metadata_spec Represents a spec for metadata.
 * @param {String} _access_level The minimum level of access required to view this metadata. (one of: UNPRIVILEGED | USER | SUPERUSER)
 */
function ElementsUpdateMetadataRequest(_metadata = undefined, _metadata_spec = undefined, _access_level = undefined) constructor
{
	metadata = _metadata;
	metadataSpec = _metadata_spec;
	accessLevel = _access_level;
}

/**
 * @func ElementsReward()
 * @param {Struct.ElementsItem} _item The Item to be issued upon redemption.
 * @param {Real} _quantity The quantity of the Item that is rewarded
 * @param {Struct} _metadata
 */
function ElementsReward(_item, _quantity, _metadata = undefined) constructor
{
	item = _item;
	quantity = _quantity;
	metadata = _metadata;
}

/**
 * @func ElementsStep()
 * @param {String} _display_name The display name for the step
 * @param {String} _description The description of the step
 * @param {Real} _count The number of times the step must be completed to receive the reward(s)
 * @param {Array[Struct.ElementsReward]} _rewards The reward(s) that will be granted upon completion
 * @param {Struct} _metadata The metadata for this step
 */
function ElementsStep(_display_name, _description, _count, _rewards, _metadata = undefined) constructor
{
	displayName = _display_name;
	description = _description;
	count = _count;
	rewards = _rewards;
	metadata = _metadata;
}

/**
 * @func ElementsMission()
 * @param {String} _id The unique ID of the mission
 * @param {String} _name The name of the mission
 * @param {String} _display_name The display name for the mission
 * @param {String} _description The description of the mission
 * @param {Array[String]} _tags The tags used to categorize this mission
 * @param {Array[Struct.ElementsStep]} _steps The steps that constitute the mission (may be null if finalRepeatStep is specified)
 * @param {Struct.ElementsStep} _final_repeat_step The final repeating step (may be null if step(s) are specified)
 * @param {Struct} _metadata The metadata for this mission
 */
function ElementsMission(_id, _name, _display_name, _description, _tags = undefined, _steps = undefined, _final_repeat_step = undefined, _metadata = undefined) constructor
{
	id = _id;
	name = _name;
	displayName = _display_name;
	description = _description;
	tags = _tags;
	steps = _steps;
	finalRepeatStep = _final_repeat_step;
	metadata = _metadata;
}

/**
 * @func ElementsPaginationMission()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsMission]} _objects
 */
function ElementsPaginationMission(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsProgressMissionInfo()
 * @param {String} _id The id of the mission
 * @param {String} _name The name of the mission
 * @param {String} _display_name The display name for the mission
 * @param {String} _description The description of the mission
 * @param {Array[Struct.ElementsStep]} _steps The steps that constitute the mission (may be null if finalRepeatStep is specified)
 * @param {Struct.ElementsStep} _final_repeat_step The final repeating step (may be null if step(s) are specified)
 * @param {Array[String]} _tags The tags used to categorize this mission
 * @param {Struct} _metadata The metadata for this mission
 */
function ElementsProgressMissionInfo(_id, _name, _display_name, _description, _steps = undefined, _final_repeat_step = undefined, _tags = undefined, _metadata = undefined) constructor
{
	id = _id;
	name = _name;
	displayName = _display_name;
	description = _description;
	steps = _steps;
	finalRepeatStep = _final_repeat_step;
	tags = _tags;
	metadata = _metadata;
}

/**
 * @func ElementsSchedule()
 * @param {String} _id The unique ID of the schedule.
 * @param {String} _name The unique name of the schedule.
 * @param {String} _display_name
 * @param {String} _description The description for this schedule.
 */
function ElementsSchedule(_id, _name, _display_name, _description) constructor
{
	id = _id;
	name = _name;
	displayName = _display_name;
	description = _description;
}

/**
 * @func ElementsScheduleEvent()
 * @param {String} _id
 * @param {Struct.ElementsSchedule} _schedule
 * @param {Array[Struct.ElementsMission]} _missions
 * @param {Real} _begin
 * @param {Real} _end
 */
function ElementsScheduleEvent(_id, _schedule, _missions, _begin = undefined, _end = undefined) constructor
{
	id = _id;
	schedule = _schedule;
	missions = _missions;
	self[$ "begin"] = _begin;
	self[$ "end"] = _end;
}

/**
 * @func ElementsProgress()
 * @param {String} _id The unique ID of the progress instance
 * @param {Struct.ElementsProfile} _profile
 * @param {Struct.ElementsProgressMissionInfo} _mission The mission
 * @param {Struct.ElementsStep} _current_step The final repeating step (may be null if step(s) are specified)
 * @param {Real} _remaining The remaining actions
 * @param {Array[Struct.ElementsRewardIssuance]} _reward_issuances List of all reward issuances that are issued but not expired, or redeemed but persistent.
 * @param {Real} _sequence The current number of completed steps. Note that this may exceed the total number of steps, i.e. the final step may be repeated infinitely.
 * @param {Real} _managed_by_schedule Indicates that this progress is managed by a Schedule. If true, the Progress will be deleted when no schedules have the progress active. This will be true if the Progress was created as part of a Schedule.
 * @param {Array[Struct.ElementsSchedule]} _schedules A listing of the Schedules which are managing this Progress. Empty or null if the Progress is not managed as part of a Schedule.
 * @param {Array[Struct.ElementsScheduleEvent]} _schedule_events A listing of ScheduleEvents which are managing this Progress. Empty or null if the Progress is not managed as part of a Schedule.
 */
function ElementsProgress(_id, _profile, _mission, _current_step = undefined, _remaining = undefined, _reward_issuances = undefined, _sequence = undefined, _managed_by_schedule = undefined, _schedules = undefined, _schedule_events = undefined) constructor
{
	id = _id;
	profile = _profile;
	mission = _mission;
	currentStep = _current_step;
	remaining = _remaining;
	rewardIssuances = _reward_issuances;
	sequence = _sequence;
	managedBySchedule = _managed_by_schedule;
	schedules = _schedules;
	scheduleEvents = _schedule_events;
}

/**
 * @func ElementsPaginationProgress()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsProgress]} _objects
 */
function ElementsPaginationProgress(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsProgressRow()
 * @param {String} _id
 * @param {String} _profile_id
 * @param {String} _profile_image_url
 * @param {String} _profile_display_name
 * @param {String} _step_display_name
 * @param {String} _step_description
 * @param {Real} _remaining
 * @param {Real} _step_count
 */
function ElementsProgressRow(_id = undefined, _profile_id = undefined, _profile_image_url = undefined, _profile_display_name = undefined, _step_display_name = undefined, _step_description = undefined, _remaining = undefined, _step_count = undefined) constructor
{
	id = _id;
	profileId = _profile_id;
	profileImageUrl = _profile_image_url;
	profileDisplayName = _profile_display_name;
	stepDisplayName = _step_display_name;
	stepDescription = _step_description;
	remaining = _remaining;
	stepCount = _step_count;
}

/**
 * @func ElementsTabulationProgressRow()
 * @param {Array[Struct.ElementsProgressRow]} _rows
 */
function ElementsTabulationProgressRow(_rows) constructor
{
	rows = _rows;
}

/**
 * @func ElementsPaginationRewardIssuance()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsRewardIssuance]} _objects
 */
function ElementsPaginationRewardIssuance(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsRewardIssuanceRedemptionResult()
 * @param {String} _reward_issuance_id The id as originally provided in the request.
 * @param {Struct.ElementsRewardIssuance} _reward_issuance Represents a Reward that has been issued but has not yet been claimed by the user.  The reward is assigned a unique ID to ensure that it may not have been applied more than once.
 * @param {Struct.ElementsInventoryItem} _inventory_item Should the redemption be successful, the Inventory Item that was updated. Otherwise, null.
 * @param {String} _error_details Should the redemption fail, the error details. Otherwise, null.
 */
function ElementsRewardIssuanceRedemptionResult(_reward_issuance_id = undefined, _reward_issuance = undefined, _inventory_item = undefined, _error_details = undefined) constructor
{
	rewardIssuanceId = _reward_issuance_id;
	rewardIssuance = _reward_issuance;
	inventoryItem = _inventory_item;
	errorDetails = _error_details;
}

/**
 * @func ElementsCreateScheduleEventRequest()
 * @param {Array[String]} _mission_names_or_ids
 * @param {Real} _begin
 * @param {Real} _end
 */
function ElementsCreateScheduleEventRequest(_mission_names_or_ids, _begin = undefined, _end = undefined) constructor
{
	missionNamesOrIds = _mission_names_or_ids;
	self[$ "begin"] = _begin;
	self[$ "end"] = _end;
}

/**
 * @func ElementsPaginationScheduleEvent()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsScheduleEvent]} _objects
 */
function ElementsPaginationScheduleEvent(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsUpdateScheduleEventRequest()
 * @param {Array[String]} _mission_names_or_ids
 * @param {Real} _begin
 * @param {Real} _end
 */
function ElementsUpdateScheduleEventRequest(_mission_names_or_ids, _begin = undefined, _end = undefined) constructor
{
	missionNamesOrIds = _mission_names_or_ids;
	self[$ "begin"] = _begin;
	self[$ "end"] = _end;
}

/**
 * @func ElementsCreateScheduleRequest()
 * @param {String} _name
 * @param {String} _display_name
 * @param {String} _description
 */
function ElementsCreateScheduleRequest(_name, _display_name, _description) constructor
{
	name = _name;
	displayName = _display_name;
	description = _description;
}

/**
 * @func ElementsPaginationSchedule()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsSchedule]} _objects
 */
function ElementsPaginationSchedule(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsUpdateScheduleRequest()
 * @param {String} _name
 * @param {String} _display_name
 * @param {String} _description
 */
function ElementsUpdateScheduleRequest(_name, _display_name, _description) constructor
{
	name = _name;
	displayName = _display_name;
	description = _description;
}

/**
 * @func ElementsFCMRegistration()
 * @param {String} _registration_token The actual Firebase registration.
 * @param {String} _id The the unique id of the token stored in the database.
 * @param {Struct.ElementsProfile} _profile
 */
function ElementsFCMRegistration(_registration_token, _id = undefined, _profile = undefined) constructor
{
	registrationToken = _registration_token;
	id = _id;
	profile = _profile;
}

/**
 * @func ElementsCreateProfileRequest()
 * @param {String} _user_id The user id this profile belongs to.
 * @param {String} _application_id The application id this profile belongs to.
 * @param {String} _image_url A URL to the image of the profile.  (ie the User's Avatar).
 * @param {String} _display_name A non-unique display name for this profile.
 * @param {Struct} _metadata A map of arbitrary metadata.
 */
function ElementsCreateProfileRequest(_user_id, _application_id, _image_url = undefined, _display_name = undefined, _metadata = undefined) constructor
{
	userId = _user_id;
	applicationId = _application_id;
	imageUrl = _image_url;
	displayName = _display_name;
	metadata = _metadata;
}

/**
 * @func ElementsUpdateProfileRequest()
 * @param {String} _image_url A URL to the image of the profile.  (ie the User's Avatar).
 * @param {String} _display_name A non-unique display name for this profile.
 * @param {Struct} _metadata A map of arbitrary metadata.
 */
function ElementsUpdateProfileRequest(_image_url = undefined, _display_name = undefined, _metadata = undefined) constructor
{
	imageUrl = _image_url;
	displayName = _display_name;
	metadata = _metadata;
}

/**
 * @func ElementsUpdateProfileImageRequest()
 * @param {String} _mime_type MimeType of image
 */
function ElementsUpdateProfileImageRequest(_mime_type) constructor
{
	mimeType = _mime_type;
}

/**
 * @func ElementsSaveDataDocument()
 * @param {String} _version The revision of the save data document.
 * @param {String} _contents The contents of the save data.
 * @param {String} _id The database assigned unique ID of the document.
 * @param {Real} _slot The slot of the property.
 * @param {Struct.ElementsUser} _user The User associated with this Profile.
 * @param {Struct.ElementsProfile} _profile
 * @param {Real} _timestamp The timestamp of the last write to this document.
 */
function ElementsSaveDataDocument(_version, _contents, _id = undefined, _slot = undefined, _user = undefined, _profile = undefined, _timestamp = undefined) constructor
{
	version = _version;
	contents = _contents;
	id = _id;
	slot = _slot;
	user = _user;
	profile = _profile;
	timestamp = _timestamp;
}

/**
 * @func ElementsCreateSaveDataDocumentRequest()
 * @param {Real} _slot The slot of the property. Must be unique for user or profile.
 * @param {String} _contents The contents of the save data.
 * @param {String} _user_id The id of the user which owns the save data. If specified, the user will own this save data and the profileId must be null or be owned by the user specified.
 * @param {String} _profile_id The id of the profile which owns the save data. If specified, the profile will own this save data and the userId must be null or be owned by the user specified.
 */
function ElementsCreateSaveDataDocumentRequest(_slot, _contents, _user_id = undefined, _profile_id = undefined) constructor
{
	slot = _slot;
	contents = _contents;
	userId = _user_id;
	profileId = _profile_id;
}

/**
 * @func ElementsPaginationSaveDataDocument()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsSaveDataDocument]} _objects
 */
function ElementsPaginationSaveDataDocument(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsUpdateSaveDataDocumentRequest()
 * @param {String} _contents
 * @param {Real} _force
 * @param {String} _version
 */
function ElementsUpdateSaveDataDocumentRequest(_contents, _force = undefined, _version = undefined) constructor
{
	contents = _contents;
	force = _force;
	version = _version;
}

/**
 * @func ElementsCreateMetadataSpecRequest()
 * @param {Array[Struct.ElementsMetadataSpecProperty]} _properties The token template tabs to create.
 * @param {String} _name The name of the metadata spec.
 * @param {String} _type The type of the metadata spec. (one of: STRING | NUMBER | BOOLEAN | ARRAY | ENUM | OBJECT | TAGS)
 */
function ElementsCreateMetadataSpecRequest(_properties, _name = undefined, _type = undefined) constructor
{
	properties = _properties;
	name = _name;
	type = _type;
}

/**
 * @func ElementsEditorLayout()
 * @param {String} _key
 * @param {String} _title
 * @param {String} _placeholder
 */
function ElementsEditorLayout(_key = undefined, _title = undefined, _placeholder = undefined) constructor
{
	key = _key;
	title = _title;
	placeholder = _placeholder;
}

/**
 * @func ElementsJsonSchema()
 * @param {String} _get_id See - https://json-schema.org/draft/2020-12/json-schema-core
 * @param {String} _get_schema See - https://json-schema.org/draft/2020-12/json-schema-core
 * @param {String} _title See - https://json-schema.org/draft/2020-12/json-schema-core
 * @param {String} _description See - https://json-schema.org/draft/2020-12/json-schema-core
 * @param {String} _type See - https://json-schema.org/draft/2020-12/json-schema-core
 * @param {Struct} _properties See - https://json-schema.org/draft/2020-12/json-schema-core
 * @param {Array[String]} _required See - https://json-schema.org/draft/2020-12/json-schema-core
 */
function ElementsJsonSchema(_get_id = undefined, _get_schema = undefined, _title = undefined, _description = undefined, _type = undefined, _properties = undefined, _required = undefined) constructor
{
	self[$ "get$id"] = _get_id;
	self[$ "get$schema"] = _get_schema;
	title = _title;
	description = _description;
	type = _type;
	properties = _properties;
	required = _required;
}

/**
 * @func ElementsEditorSchema()
 * @param {Struct} _data The data itself.
 * @param {Struct.ElementsJsonSchema} _schema A Subset of the JSON-Schema - https://json-schema.org/draft/2020-12/json-schema-core
 * @param {Array[Struct.ElementsEditorLayout]} _layout The editor layout.
 */
function ElementsEditorSchema(_data = undefined, _schema = undefined, _layout = undefined) constructor
{
	data = _data;
	schema = _schema;
	layout = _layout;
}

/**
 * @func ElementsJsonSchemaProperty()
 * @param {String} _type See - https://json-schema.org/draft/2020-12/json-schema-core
 * @param {String} _title See - https://json-schema.org/draft/2020-12/json-schema-core
 * @param {String} _description See - https://json-schema.org/draft/2020-12/json-schema-core
 * @param {Array[String]} _required See - https://json-schema.org/draft/2020-12/json-schema-core
 */
function ElementsJsonSchemaProperty(_type = undefined, _title = undefined, _description = undefined, _required = undefined) constructor
{
	type = _type;
	title = _title;
	description = _description;
	required = _required;
}

/**
 * @func ElementsPaginationMetadataSpec()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsMetadataSpec]} _objects
 */
function ElementsPaginationMetadataSpec(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsUpdateMetadataSpecRequest()
 * @param {String} _name The name of the metadata spec.
 * @param {String} _type The type of the metadata spec. (one of: STRING | NUMBER | BOOLEAN | ARRAY | ENUM | OBJECT | TAGS)
 * @param {Array[Struct.ElementsMetadataSpecProperty]} _properties The updated list of properties.
 */
function ElementsUpdateMetadataSpecRequest(_name = undefined, _type = undefined, _properties = undefined) constructor
{
	name = _name;
	type = _type;
	properties = _properties;
}

/**
 * @func ElementsMockSessionCreation()
 * @param {String} _session_secret The Session Secret to pass to subsequent requests through headers.
 * @param {Struct.ElementsSession} _session The Session object generated by the request.
 * @param {Real} _user_expires_at The assocaited mock user will automatically be deleted at supplied time.
 * @param {String} _password The randomly-assigned password for the mock user.
 */
function ElementsMockSessionCreation(_session_secret = undefined, _session = undefined, _user_expires_at = undefined, _password = undefined) constructor
{
	sessionSecret = _session_secret;
	session = _session;
	userExpiresAt = _user_expires_at;
	password = _password;
}

/**
 * @func ElementsMockSessionRequest()
 * @param {Real} _lifetime_in_seconds The lifetime of the user in seconds.  After this amount of time,
 * @param {Struct.ElementsApplication} _application
 */
function ElementsMockSessionRequest(_lifetime_in_seconds = undefined, _application = undefined) constructor
{
	lifetimeInSeconds = _lifetime_in_seconds;
	application = _application;
}

/**
 * @func ElementsUsernamePasswordSessionRequest()
 * @param {String} _user_id The user ID.
 * @param {String} _password The password.
 * @param {String} _profile_id The profile ID to assign to the session.
 * @param {String} _profile_selector A query string to select the profile to use.
 */
function ElementsUsernamePasswordSessionRequest(_user_id, _password, _profile_id = undefined, _profile_selector = undefined) constructor
{
	userId = _user_id;
	password = _password;
	profileId = _profile_id;
	profileSelector = _profile_selector;
}

/**
 * @func ElementsDatabaseHealthStatus()
 * @param {String} _name
 * @param {String} _metadata
 */
function ElementsDatabaseHealthStatus(_name = undefined, _metadata = undefined) constructor
{
	name = _name;
	metadata = _metadata;
}

/**
 * @func ElementsDiscoveryHealthStatus()
 * @param {Array[String]} _records
 * @param {Array[String]} _known_hosts
 */
function ElementsDiscoveryHealthStatus(_records = undefined, _known_hosts = undefined) constructor
{
	records = _records;
	knownHosts = _known_hosts;
}

/**
 * @func ElementsInstanceHealthStatus()
 * @param {String} _instance_id
 * @param {Array[String]} _node_ids
 */
function ElementsInstanceHealthStatus(_instance_id = undefined, _node_ids = undefined) constructor
{
	instanceId = _instance_id;
	nodeIds = _node_ids;
}

/**
 * @func ElementsRoutingHealthStatus()
 * @param {String} _instance_id
 * @param {Array[String]} _routing_table
 * @param {Array[String]} _master_node_routing_table
 * @param {Array[String]} _application_node_routing_table
 */
function ElementsRoutingHealthStatus(_instance_id = undefined, _routing_table = undefined, _master_node_routing_table = undefined, _application_node_routing_table = undefined) constructor
{
	instanceId = _instance_id;
	routingTable = _routing_table;
	masterNodeRoutingTable = _master_node_routing_table;
	applicationNodeRoutingTable = _application_node_routing_table;
}

/**
 * @func ElementsInvokerHealthStatus()
 * @param {Array[String]} _priorities
 * @param {Array[String]} _connected_peers
 */
function ElementsInvokerHealthStatus(_priorities = undefined, _connected_peers = undefined) constructor
{
	priorities = _priorities;
	connectedPeers = _connected_peers;
}

/**
 * @func ElementsHealthStatus()
 * @param {Real} _checks_failed
 * @param {Real} _checks_performed
 * @param {Real} _overall_health
 * @param {Array[String]} _problems
 * @param {Struct.ElementsInstanceHealthStatus} _instance_status
 * @param {Array[Struct.ElementsDatabaseHealthStatus]} _database_status
 * @param {Struct.ElementsDiscoveryHealthStatus} _discovery_health_status
 * @param {Struct.ElementsRoutingHealthStatus} _routing_health_status
 * @param {Struct.ElementsInvokerHealthStatus} _invoker_health_status
 */
function ElementsHealthStatus(_checks_failed = undefined, _checks_performed = undefined, _overall_health = undefined, _problems = undefined, _instance_status = undefined, _database_status = undefined, _discovery_health_status = undefined, _routing_health_status = undefined, _invoker_health_status = undefined) constructor
{
	checksFailed = _checks_failed;
	checksPerformed = _checks_performed;
	overallHealth = _overall_health;
	problems = _problems;
	instanceStatus = _instance_status;
	databaseStatus = _database_status;
	discoveryHealthStatus = _discovery_health_status;
	routingHealthStatus = _routing_health_status;
	invokerHealthStatus = _invoker_health_status;
}

/**
 * @func ElementsVersion()
 * @param {String} _version
 * @param {String} _revision
 * @param {String} _timestamp
 */
function ElementsVersion(_version = undefined, _revision = undefined, _timestamp = undefined) constructor
{
	version = _version;
	revision = _revision;
	timestamp = _timestamp;
}

/**
 * @func ElementsUserCreateResponse()
 * @param {String} _id
 * @param {String} _name
 * @param {String} _email
 * @param {String} _first_name
 * @param {String} _last_name
 * @param {String} _level  (one of: UNPRIVILEGED | USER | SUPERUSER)
 * @param {Real} _active
 * @param {String} _facebook_id
 * @param {String} _firebase_id
 * @param {String} _apple_sign_in_id
 * @param {String} _primary_phone_nb
 * @param {Array[Struct.ElementsProfile]} _profiles
 * @param {String} _password
 * @param {Array[String]} _linked_accounts
 */
function ElementsUserCreateResponse(_id = undefined, _name = undefined, _email = undefined, _first_name = undefined, _last_name = undefined, _level = undefined, _active = undefined, _facebook_id = undefined, _firebase_id = undefined, _apple_sign_in_id = undefined, _primary_phone_nb = undefined, _profiles = undefined, _password = undefined, _linked_accounts = undefined) constructor
{
	id = _id;
	name = _name;
	email = _email;
	firstName = _first_name;
	lastName = _last_name;
	level = _level;
	active = _active;
	facebookId = _facebook_id;
	firebaseId = _firebase_id;
	appleSignInId = _apple_sign_in_id;
	primaryPhoneNb = _primary_phone_nb;
	profiles = _profiles;
	password = _password;
	linkedAccounts = _linked_accounts;
}

/**
 * @func ElementsCreateProfileSignupRequest()
 * @param {String} _application_id The application id this profile belongs to.
 * @param {String} _display_name A non-unique display name for this profile. If left null, the server will assign.
 * @param {String} _image_url A URL to the image of the profile.  (ie the User's Avatar). If left null, the server will no assign any URL.
 */
function ElementsCreateProfileSignupRequest(_application_id, _display_name = undefined, _image_url = undefined) constructor
{
	applicationId = _application_id;
	displayName = _display_name;
	imageUrl = _image_url;
}

/**
 * @func ElementsUserCreateRequest()
 * @param {String} _name
 * @param {String} _email
 * @param {String} _primary_phone_nb
 * @param {String} _first_name
 * @param {String} _last_name
 * @param {String} _password The user's plaintext password, only to be provided in POST/PUT requests in the User Resource REST API interface. In the future, a dedicated REST API model may be constructed instead of using a direct User model.
 * @param {String} _level The user's level to assign. Depending on the usage, the server may ignore this field and assign its own description. (one of: UNPRIVILEGED | USER | SUPERUSER)
 * @param {Array[Struct.ElementsCreateProfileSignupRequest]} _profiles A list of profiles to assign to this user during creation. The server will attempt to create a profile for each item in this list.
 */
function ElementsUserCreateRequest(_name = undefined, _email = undefined, _primary_phone_nb = undefined, _first_name = undefined, _last_name = undefined, _password = undefined, _level = undefined, _profiles = undefined) constructor
{
	name = _name;
	email = _email;
	primaryPhoneNb = _primary_phone_nb;
	firstName = _first_name;
	lastName = _last_name;
	password = _password;
	level = _level;
	profiles = _profiles;
}

/**
 * @func ElementsPaginationUser()
 * @param {Real} _offset
 * @param {Real} _total
 * @param {Real} _approximation
 * @param {Array[Struct.ElementsUser]} _objects
 */
function ElementsPaginationUser(_offset = undefined, _total = undefined, _approximation = undefined, _objects = undefined) constructor
{
	offset = _offset;
	total = _total;
	approximation = _approximation;
	objects = _objects;
}

/**
 * @func ElementsUserUpdateRequest()
 * @param {String} _name
 * @param {String} _email
 * @param {String} _level  (one of: UNPRIVILEGED | USER | SUPERUSER)
 * @param {String} _primary_phone_nb
 * @param {String} _first_name
 * @param {String} _last_name
 * @param {String} _password The user's plaintext password, only to be provided in POST/PUT requests in the User Resource REST API interface. In the future, a dedicated REST API model may be constructed instead of using a direct User model.
 */
function ElementsUserUpdateRequest(_name, _email, _level, _primary_phone_nb = undefined, _first_name = undefined, _last_name = undefined, _password = undefined) constructor
{
	name = _name;
	email = _email;
	level = _level;
	primaryPhoneNb = _primary_phone_nb;
	firstName = _first_name;
	lastName = _last_name;
	password = _password;
}

/**
 * @func ElementsUserUpdatePasswordRequest()
 * @param {String} _old_password The user's current password.
 * @param {String} _new_password The user's updated password.
 * @param {String} _profile_id The user's profile id to assign the new session. Leave blank for no profile id.
 */
function ElementsUserUpdatePasswordRequest(_old_password, _new_password, _profile_id = undefined) constructor
{
	oldPassword = _old_password;
	newPassword = _new_password;
	profileId = _profile_id;
}

/**
 * @func ElementsErrorResponse()
 * @param {String} _code A machine readable code of the error.
 * @param {String} _message A description of the error. This error is not intended to be displayed to the end-user, rather it is it designed to relay information to the application developer.
 */
function ElementsErrorResponse(_code = undefined, _message = undefined) constructor
{
	code = _code;
	message = _message;
}

/**
 * @func ElementsMetadataSpecProperty_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsMetadataSpecProperty_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsMetadataSpecProperty_validate";
	
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
	if (!is_undefined(_inst[$ "required"]) && !is_real(_inst[$ "required"])) show_error($"{_where} :: 'required' expected bool", true);
	if (!is_undefined(_inst[$ "placeholder"]) && !is_string(_inst[$ "placeholder"])) show_error($"{_where} :: 'placeholder' expected string", true);
	if (!is_undefined(_inst[$ "defaultValue"]) && !is_struct(_inst[$ "defaultValue"])) show_error($"{_where} :: 'defaultValue' expected any", true);
	if (!is_undefined(_inst[$ "properties"]) && !is_array(_inst[$ "properties"])) show_error($"{_where} :: 'properties' expected ElementsMetadataSpecProperty", true);
}

/**
 * @func ElementsMetadataSpec_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsMetadataSpec_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsMetadataSpec_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
	if (!is_array(_inst[$ "properties"])) show_error($"{_where} :: 'properties' expected ElementsMetadataSpecProperty", true);
}

/**
 * @func ElementsItem_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsItem_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsItem_validate";
	
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_string(_inst[$ "category"])) show_error($"{_where} :: 'category' expected string", true);
	if (!is_undefined(_inst[$ "id"]) && !is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_undefined(_inst[$ "tags"]) && !is_array(_inst[$ "tags"])) show_error($"{_where} :: 'tags' expected string", true);
	if (!is_undefined(_inst[$ "metadataSpec"]))
	{
		if (!is_struct(_inst[$ "metadataSpec"])) show_error($"{_where} :: 'metadataSpec' expected ElementsMetadataSpec", true);
		ElementsMetadataSpec_validate(_inst[$ "metadataSpec"], _where);
	}
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
	if (!is_undefined(_inst[$ "publicVisible"]) && !is_real(_inst[$ "publicVisible"])) show_error($"{_where} :: 'publicVisible' expected bool", true);
}

/**
 * @func ElementsUser_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUser_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUser_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "level"])) show_error($"{_where} :: 'level' expected string", true);
	if (!is_undefined(_inst[$ "name"]) && !is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_undefined(_inst[$ "firstName"]) && !is_string(_inst[$ "firstName"])) show_error($"{_where} :: 'firstName' expected string", true);
	if (!is_undefined(_inst[$ "lastName"]) && !is_string(_inst[$ "lastName"])) show_error($"{_where} :: 'lastName' expected string", true);
	if (!is_undefined(_inst[$ "email"]) && !is_string(_inst[$ "email"])) show_error($"{_where} :: 'email' expected string", true);
	if (!is_undefined(_inst[$ "primaryPhoneNb"]) && !is_string(_inst[$ "primaryPhoneNb"])) show_error($"{_where} :: 'primaryPhoneNb' expected string", true);
	if (!is_undefined(_inst[$ "linkedAccounts"]) && !is_array(_inst[$ "linkedAccounts"])) show_error($"{_where} :: 'linkedAccounts' expected string", true);
}

/**
 * @func ElementsRewardIssuance_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsRewardIssuance_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsRewardIssuance_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_struct(_inst[$ "user"])) show_error($"{_where} :: 'user' expected ElementsUser", true);
	_inst[$ "user"].validate(_where);
	if (!is_string(_inst[$ "state"])) show_error($"{_where} :: 'state' expected string", true);
	if (!is_string(_inst[$ "context"])) show_error($"{_where} :: 'context' expected string", true);
	if (!is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
	if (!is_undefined(_inst[$ "item"]))
	{
		if (!is_struct(_inst[$ "item"])) show_error($"{_where} :: 'item' expected ElementsItem", true);
		ElementsItem_validate(_inst[$ "item"], _where);
	}
	if (!is_undefined(_inst[$ "itemQuantity"]) && !is_real(_inst[$ "itemQuantity"])) show_error($"{_where} :: 'itemQuantity' expected int32", true);
	if (!is_undefined(_inst[$ "source"]) && !is_string(_inst[$ "source"])) show_error($"{_where} :: 'source' expected string", true);
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
	if (!is_undefined(_inst[$ "tags"]) && !is_array(_inst[$ "tags"])) show_error($"{_where} :: 'tags' expected string", true);
	if (!is_undefined(_inst[$ "expirationTimestamp"]) && !is_real(_inst[$ "expirationTimestamp"])) show_error($"{_where} :: 'expirationTimestamp' expected int64", true);
	if (!is_undefined(_inst[$ "uuid"]) && !is_string(_inst[$ "uuid"])) show_error($"{_where} :: 'uuid' expected string", true);
}

/**
 * @func ElementsCreateAppleIapReceipt_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateAppleIapReceipt_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateAppleIapReceipt_validate";
	
	if (!is_string(_inst[$ "receiptData"])) show_error($"{_where} :: 'receiptData' expected string", true);
	if (!is_undefined(_inst[$ "createAppleIapReceiptEnvironment"]) && !is_string(_inst[$ "createAppleIapReceiptEnvironment"])) show_error($"{_where} :: 'createAppleIapReceiptEnvironment' expected string", true);
}

/**
 * @func ElementsApplicationConfiguration_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsApplicationConfiguration_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsApplicationConfiguration_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
	if (!is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_struct(_inst[$ "parent"])) show_error($"{_where} :: 'parent' expected ElementsApplication", true);
	_inst[$ "parent"].validate(_where);
}

/**
 * @func ElementsApplication_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsApplication_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsApplication_validate";
	
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_undefined(_inst[$ "id"]) && !is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_undefined(_inst[$ "description"]) && !is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_undefined(_inst[$ "gitBranch"]) && !is_string(_inst[$ "gitBranch"])) show_error($"{_where} :: 'gitBranch' expected string", true);
	if (!is_undefined(_inst[$ "scriptRepoUrl"]) && !is_string(_inst[$ "scriptRepoUrl"])) show_error($"{_where} :: 'scriptRepoUrl' expected string", true);
	if (!is_undefined(_inst[$ "httpDocumentationUrl"]) && !is_string(_inst[$ "httpDocumentationUrl"])) show_error($"{_where} :: 'httpDocumentationUrl' expected string", true);
	if (!is_undefined(_inst[$ "httpDocumentationUiUrl"]) && !is_string(_inst[$ "httpDocumentationUiUrl"])) show_error($"{_where} :: 'httpDocumentationUiUrl' expected string", true);
	if (!is_undefined(_inst[$ "httpTunnelEndpointUrl"]) && !is_string(_inst[$ "httpTunnelEndpointUrl"])) show_error($"{_where} :: 'httpTunnelEndpointUrl' expected string", true);
	if (!is_undefined(_inst[$ "attributes"]) && !is_struct(_inst[$ "attributes"])) show_error($"{_where} :: 'attributes' expected any", true);
	if (!is_undefined(_inst[$ "applicationConfiguration"]))
	{
		if (!is_struct(_inst[$ "applicationConfiguration"])) show_error($"{_where} :: 'applicationConfiguration' expected ElementsApplicationConfiguration", true);
		ElementsApplicationConfiguration_validate(_inst[$ "applicationConfiguration"], _where);
	}
}

/**
 * @func ElementsPaginationApplicationConfiguration_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationApplicationConfiguration_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationApplicationConfiguration_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsApplicationConfiguration", true);
}

/**
 * @func ElementsCreateApplicationRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateApplicationRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateApplicationRequest_validate";
	
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_undefined(_inst[$ "description"]) && !is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_undefined(_inst[$ "attributes"]) && !is_struct(_inst[$ "attributes"])) show_error($"{_where} :: 'attributes' expected any", true);
}

/**
 * @func ElementsPaginationApplication_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationApplication_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationApplication_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsApplication", true);
}

/**
 * @func ElementsUpdateApplicationRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateApplicationRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateApplicationRequest_validate";
	
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_undefined(_inst[$ "description"]) && !is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_undefined(_inst[$ "attributes"]) && !is_struct(_inst[$ "attributes"])) show_error($"{_where} :: 'attributes' expected any", true);
}

/**
 * @func ElementsFacebookApplicationConfiguration_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsFacebookApplicationConfiguration_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsFacebookApplicationConfiguration_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
	if (!is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_struct(_inst[$ "parent"])) show_error($"{_where} :: 'parent' expected ElementsApplication", true);
	_inst[$ "parent"].validate(_where);
	if (!is_string(_inst[$ "applicationId"])) show_error($"{_where} :: 'applicationId' expected string", true);
	if (!is_string(_inst[$ "applicationSecret"])) show_error($"{_where} :: 'applicationSecret' expected string", true);
	if (!is_undefined(_inst[$ "builtinApplicationPermissions"]) && !is_array(_inst[$ "builtinApplicationPermissions"])) show_error($"{_where} :: 'builtinApplicationPermissions' expected string", true);
}

/**
 * @func ElementsFirebaseApplicationConfiguration_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsFirebaseApplicationConfiguration_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsFirebaseApplicationConfiguration_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
	if (!is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_struct(_inst[$ "parent"])) show_error($"{_where} :: 'parent' expected ElementsApplication", true);
	_inst[$ "parent"].validate(_where);
	if (!is_string(_inst[$ "projectId"])) show_error($"{_where} :: 'projectId' expected string", true);
	if (!is_string(_inst[$ "serviceAccountCredentials"])) show_error($"{_where} :: 'serviceAccountCredentials' expected string", true);
}

/**
 * @func ElementsProductBundleReward_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsProductBundleReward_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsProductBundleReward_validate";
	
	if (!is_string(_inst[$ "itemId"])) show_error($"{_where} :: 'itemId' expected string", true);
	if (!is_real(_inst[$ "quantity"])) show_error($"{_where} :: 'quantity' expected int32", true);
}

/**
 * @func ElementsProductBundle_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsProductBundle_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsProductBundle_validate";
	
	if (!is_string(_inst[$ "productId"])) show_error($"{_where} :: 'productId' expected string", true);
	if (!is_array(_inst[$ "productBundleRewards"])) show_error($"{_where} :: 'productBundleRewards' expected ElementsProductBundleReward", true);
	if (!is_real(_inst[$ "display"])) show_error($"{_where} :: 'display' expected bool", true);
	if (!is_undefined(_inst[$ "displayName"]) && !is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_undefined(_inst[$ "description"]) && !is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
}

/**
 * @func ElementsGooglePlayApplicationConfiguration_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsGooglePlayApplicationConfiguration_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsGooglePlayApplicationConfiguration_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
	if (!is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_struct(_inst[$ "parent"])) show_error($"{_where} :: 'parent' expected ElementsApplication", true);
	_inst[$ "parent"].validate(_where);
	if (!is_undefined(_inst[$ "applicationId"]) && !is_string(_inst[$ "applicationId"])) show_error($"{_where} :: 'applicationId' expected string", true);
	if (!is_undefined(_inst[$ "jsonKey"]) && !is_struct(_inst[$ "jsonKey"])) show_error($"{_where} :: 'jsonKey' expected any", true);
	if (!is_undefined(_inst[$ "productBundles"]) && !is_array(_inst[$ "productBundles"])) show_error($"{_where} :: 'productBundles' expected ElementsProductBundle", true);
}

/**
 * @func ElementsIosApplicationConfiguration_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsIosApplicationConfiguration_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsIosApplicationConfiguration_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
	if (!is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_struct(_inst[$ "parent"])) show_error($"{_where} :: 'parent' expected ElementsApplication", true);
	_inst[$ "parent"].validate(_where);
	if (!is_string(_inst[$ "applicationId"])) show_error($"{_where} :: 'applicationId' expected string", true);
	if (!is_undefined(_inst[$ "productBundles"]) && !is_array(_inst[$ "productBundles"])) show_error($"{_where} :: 'productBundles' expected ElementsProductBundle", true);
}

/**
 * @func ElementsElementServiceReference_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsElementServiceReference_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsElementServiceReference_validate";
	
	if (!is_string(_inst[$ "elementName"])) show_error($"{_where} :: 'elementName' expected string", true);
	if (!is_undefined(_inst[$ "serviceType"]) && !is_string(_inst[$ "serviceType"])) show_error($"{_where} :: 'serviceType' expected string", true);
	if (!is_undefined(_inst[$ "serviceName"]) && !is_string(_inst[$ "serviceName"])) show_error($"{_where} :: 'serviceName' expected string", true);
}

/**
 * @func ElementsCallbackDefinition_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCallbackDefinition_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCallbackDefinition_validate";
	
	if (!is_string(_inst[$ "method"])) show_error($"{_where} :: 'method' expected string", true);
	if (!is_struct(_inst[$ "service"])) show_error($"{_where} :: 'service' expected ElementsElementServiceReference", true);
	_inst[$ "service"].validate(_where);
}

/**
 * @func ElementsMatchmakingApplicationConfiguration_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsMatchmakingApplicationConfiguration_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsMatchmakingApplicationConfiguration_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
	if (!is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_struct(_inst[$ "parent"])) show_error($"{_where} :: 'parent' expected ElementsApplication", true);
	_inst[$ "parent"].validate(_where);
	if (!is_undefined(_inst[$ "success"]))
	{
		if (!is_struct(_inst[$ "success"])) show_error($"{_where} :: 'success' expected ElementsCallbackDefinition", true);
		ElementsCallbackDefinition_validate(_inst[$ "success"], _where);
	}
	if (!is_undefined(_inst[$ "matchmaker"]))
	{
		if (!is_struct(_inst[$ "matchmaker"])) show_error($"{_where} :: 'matchmaker' expected ElementsElementServiceReference", true);
		ElementsElementServiceReference_validate(_inst[$ "matchmaker"], _where);
	}
	if (!is_undefined(_inst[$ "maxProfiles"]) && !is_real(_inst[$ "maxProfiles"])) show_error($"{_where} :: 'maxProfiles' expected int32", true);
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
	if (!is_undefined(_inst[$ "metadataSpec"]))
	{
		if (!is_struct(_inst[$ "metadataSpec"])) show_error($"{_where} :: 'metadataSpec' expected ElementsMetadataSpec", true);
		ElementsMetadataSpec_validate(_inst[$ "metadataSpec"], _where);
	}
}

/**
 * @func ElementsPSNApplicationConfiguration_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPSNApplicationConfiguration_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPSNApplicationConfiguration_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
	if (!is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_struct(_inst[$ "parent"])) show_error($"{_where} :: 'parent' expected ElementsApplication", true);
	_inst[$ "parent"].validate(_where);
	if (!is_string(_inst[$ "npIdentifier"])) show_error($"{_where} :: 'npIdentifier' expected string", true);
	if (!is_string(_inst[$ "clientSecret"])) show_error($"{_where} :: 'clientSecret' expected string", true);
}

/**
 * @func ElementsAuthScheme_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsAuthScheme_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsAuthScheme_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "audience"])) show_error($"{_where} :: 'audience' expected string", true);
	if (!is_string(_inst[$ "publicKey"])) show_error($"{_where} :: 'publicKey' expected string", true);
	if (!is_string(_inst[$ "algorithm"])) show_error($"{_where} :: 'algorithm' expected string", true);
	if (!is_string(_inst[$ "userLevel"])) show_error($"{_where} :: 'userLevel' expected string", true);
	if (!is_array(_inst[$ "tags"])) show_error($"{_where} :: 'tags' expected string", true);
	if (!is_array(_inst[$ "allowedIssuers"])) show_error($"{_where} :: 'allowedIssuers' expected string", true);
}

/**
 * @func ElementsCreateAuthSchemeResponse_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateAuthSchemeResponse_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateAuthSchemeResponse_validate";
	
	if (!is_struct(_inst[$ "scheme"])) show_error($"{_where} :: 'scheme' expected ElementsAuthScheme", true);
	_inst[$ "scheme"].validate(_where);
	if (!is_string(_inst[$ "publicKey"])) show_error($"{_where} :: 'publicKey' expected string", true);
	if (!is_undefined(_inst[$ "privateKey"]) && !is_string(_inst[$ "privateKey"])) show_error($"{_where} :: 'privateKey' expected string", true);
}

/**
 * @func ElementsCreateAuthSchemeRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateAuthSchemeRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateAuthSchemeRequest_validate";
	
	if (!is_string(_inst[$ "audience"])) show_error($"{_where} :: 'audience' expected string", true);
	if (!is_string(_inst[$ "algorithm"])) show_error($"{_where} :: 'algorithm' expected string", true);
	if (!is_string(_inst[$ "userLevel"])) show_error($"{_where} :: 'userLevel' expected string", true);
	if (!is_array(_inst[$ "tags"])) show_error($"{_where} :: 'tags' expected string", true);
	if (!is_array(_inst[$ "allowedIssuers"])) show_error($"{_where} :: 'allowedIssuers' expected string", true);
	if (!is_undefined(_inst[$ "publicKey"]) && !is_string(_inst[$ "publicKey"])) show_error($"{_where} :: 'publicKey' expected string", true);
}

/**
 * @func ElementsPaginationAuthScheme_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationAuthScheme_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationAuthScheme_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsAuthScheme", true);
}

/**
 * @func ElementsUpdateAuthSchemeResponse_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateAuthSchemeResponse_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateAuthSchemeResponse_validate";
	
	if (!is_string(_inst[$ "publicKey"])) show_error($"{_where} :: 'publicKey' expected string", true);
	if (!is_undefined(_inst[$ "scheme"]))
	{
		if (!is_struct(_inst[$ "scheme"])) show_error($"{_where} :: 'scheme' expected ElementsAuthScheme", true);
		ElementsAuthScheme_validate(_inst[$ "scheme"], _where);
	}
	if (!is_undefined(_inst[$ "privateKey"]) && !is_string(_inst[$ "privateKey"])) show_error($"{_where} :: 'privateKey' expected string", true);
}

/**
 * @func ElementsUpdateAuthSchemeRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateAuthSchemeRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateAuthSchemeRequest_validate";
	
	if (!is_string(_inst[$ "audience"])) show_error($"{_where} :: 'audience' expected string", true);
	if (!is_string(_inst[$ "algorithm"])) show_error($"{_where} :: 'algorithm' expected string", true);
	if (!is_string(_inst[$ "userLevel"])) show_error($"{_where} :: 'userLevel' expected string", true);
	if (!is_array(_inst[$ "tags"])) show_error($"{_where} :: 'tags' expected string", true);
	if (!is_array(_inst[$ "allowedIssuers"])) show_error($"{_where} :: 'allowedIssuers' expected string", true);
	if (!is_undefined(_inst[$ "regenerate"]) && !is_real(_inst[$ "regenerate"])) show_error($"{_where} :: 'regenerate' expected bool", true);
	if (!is_undefined(_inst[$ "publicKey"]) && !is_string(_inst[$ "publicKey"])) show_error($"{_where} :: 'publicKey' expected string", true);
}

/**
 * @func ElementsLargeObjectReference_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsLargeObjectReference_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsLargeObjectReference_validate";
	
	if (!is_undefined(_inst[$ "id"]) && !is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_undefined(_inst[$ "url"]) && !is_string(_inst[$ "url"])) show_error($"{_where} :: 'url' expected string", true);
	if (!is_undefined(_inst[$ "mimeType"]) && !is_string(_inst[$ "mimeType"])) show_error($"{_where} :: 'mimeType' expected string", true);
	if (!is_undefined(_inst[$ "state"]) && !is_string(_inst[$ "state"])) show_error($"{_where} :: 'state' expected string", true);
	if (!is_undefined(_inst[$ "lastModified"]) && !is_string(_inst[$ "lastModified"])) show_error($"{_where} :: 'lastModified' expected string", true);
}

/**
 * @func ElementsProfile_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsProfile_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsProfile_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_struct(_inst[$ "user"])) show_error($"{_where} :: 'user' expected ElementsUser", true);
	_inst[$ "user"].validate(_where);
	if (!is_struct(_inst[$ "application"])) show_error($"{_where} :: 'application' expected ElementsApplication", true);
	_inst[$ "application"].validate(_where);
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_undefined(_inst[$ "imageUrl"]) && !is_string(_inst[$ "imageUrl"])) show_error($"{_where} :: 'imageUrl' expected string", true);
	if (!is_undefined(_inst[$ "imageObject"]))
	{
		if (!is_struct(_inst[$ "imageObject"])) show_error($"{_where} :: 'imageObject' expected ElementsLargeObjectReference", true);
		ElementsLargeObjectReference_validate(_inst[$ "imageObject"], _where);
	}
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
	if (!is_undefined(_inst[$ "lastLogin"]) && !is_real(_inst[$ "lastLogin"])) show_error($"{_where} :: 'lastLogin' expected int64", true);
}

/**
 * @func ElementsSession_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsSession_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsSession_validate";
	
	if (!is_struct(_inst[$ "user"])) show_error($"{_where} :: 'user' expected ElementsUser", true);
	_inst[$ "user"].validate(_where);
	if (!is_undefined(_inst[$ "profile"]))
	{
		if (!is_struct(_inst[$ "profile"])) show_error($"{_where} :: 'profile' expected ElementsProfile", true);
		ElementsProfile_validate(_inst[$ "profile"], _where);
	}
	if (!is_undefined(_inst[$ "application"]))
	{
		if (!is_struct(_inst[$ "application"])) show_error($"{_where} :: 'application' expected ElementsApplication", true);
		ElementsApplication_validate(_inst[$ "application"], _where);
	}
	if (!is_undefined(_inst[$ "expiry"]) && !is_real(_inst[$ "expiry"])) show_error($"{_where} :: 'expiry' expected int64", true);
}

/**
 * @func ElementsSessionCreation_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsSessionCreation_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsSessionCreation_validate";
	
	if (!is_undefined(_inst[$ "sessionSecret"]) && !is_string(_inst[$ "sessionSecret"])) show_error($"{_where} :: 'sessionSecret' expected string", true);
	if (!is_undefined(_inst[$ "session"]))
	{
		if (!is_struct(_inst[$ "session"])) show_error($"{_where} :: 'session' expected ElementsSession", true);
		ElementsSession_validate(_inst[$ "session"], _where);
	}
}

/**
 * @func ElementsOAuth2SessionRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsOAuth2SessionRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsOAuth2SessionRequest_validate";
	
	if (!is_string(_inst[$ "schemeId"])) show_error($"{_where} :: 'schemeId' expected string", true);
	if (!is_undefined(_inst[$ "requestParameters"]) && !is_struct(_inst[$ "requestParameters"])) show_error($"{_where} :: 'requestParameters' expected any", true);
	if (!is_undefined(_inst[$ "requestHeaders"]) && !is_struct(_inst[$ "requestHeaders"])) show_error($"{_where} :: 'requestHeaders' expected any", true);
	if (!is_undefined(_inst[$ "profileId"]) && !is_string(_inst[$ "profileId"])) show_error($"{_where} :: 'profileId' expected string", true);
	if (!is_undefined(_inst[$ "profileSelector"]) && !is_string(_inst[$ "profileSelector"])) show_error($"{_where} :: 'profileSelector' expected string", true);
}

/**
 * @func ElementsOAuth2RequestKeyValue_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsOAuth2RequestKeyValue_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsOAuth2RequestKeyValue_validate";
	
	if (!is_undefined(_inst[$ "key"]) && !is_string(_inst[$ "key"])) show_error($"{_where} :: 'key' expected string", true);
	if (!is_undefined(_inst[$ "value"]) && !is_string(_inst[$ "value"])) show_error($"{_where} :: 'value' expected string", true);
	if (!is_undefined(_inst[$ "fromClient"]) && !is_real(_inst[$ "fromClient"])) show_error($"{_where} :: 'fromClient' expected bool", true);
}

/**
 * @func ElementsOAuth2AuthScheme_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsOAuth2AuthScheme_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsOAuth2AuthScheme_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "validationUrl"])) show_error($"{_where} :: 'validationUrl' expected string", true);
	if (!is_undefined(_inst[$ "headers"]) && !is_array(_inst[$ "headers"])) show_error($"{_where} :: 'headers' expected ElementsOAuth2RequestKeyValue", true);
	if (!is_undefined(_inst[$ "params"]) && !is_array(_inst[$ "params"])) show_error($"{_where} :: 'params' expected ElementsOAuth2RequestKeyValue", true);
	if (!is_undefined(_inst[$ "responseIdMapping"]) && !is_string(_inst[$ "responseIdMapping"])) show_error($"{_where} :: 'responseIdMapping' expected string", true);
}

/**
 * @func ElementsCreateOrUpdateOAuth2AuthSchemeResponse_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateOrUpdateOAuth2AuthSchemeResponse_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateOrUpdateOAuth2AuthSchemeResponse_validate";
	
	if (!is_undefined(_inst[$ "scheme"]))
	{
		if (!is_struct(_inst[$ "scheme"])) show_error($"{_where} :: 'scheme' expected ElementsOAuth2AuthScheme", true);
		ElementsOAuth2AuthScheme_validate(_inst[$ "scheme"], _where);
	}
}

/**
 * @func ElementsCreateOrUpdateOAuth2AuthSchemeRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateOrUpdateOAuth2AuthSchemeRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateOrUpdateOAuth2AuthSchemeRequest_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "validationUrl"])) show_error($"{_where} :: 'validationUrl' expected string", true);
	if (!is_undefined(_inst[$ "headers"]) && !is_array(_inst[$ "headers"])) show_error($"{_where} :: 'headers' expected ElementsOAuth2RequestKeyValue", true);
	if (!is_undefined(_inst[$ "params"]) && !is_array(_inst[$ "params"])) show_error($"{_where} :: 'params' expected ElementsOAuth2RequestKeyValue", true);
	if (!is_undefined(_inst[$ "responseIdMapping"]) && !is_string(_inst[$ "responseIdMapping"])) show_error($"{_where} :: 'responseIdMapping' expected string", true);
}

/**
 * @func ElementsPaginationOAuth2AuthScheme_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationOAuth2AuthScheme_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationOAuth2AuthScheme_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsOAuth2AuthScheme", true);
}

/**
 * @func ElementsOidcSessionRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsOidcSessionRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsOidcSessionRequest_validate";
	
	if (!is_string(_inst[$ "jwt"])) show_error($"{_where} :: 'jwt' expected string", true);
	if (!is_undefined(_inst[$ "profileId"]) && !is_string(_inst[$ "profileId"])) show_error($"{_where} :: 'profileId' expected string", true);
	if (!is_undefined(_inst[$ "profileSelector"]) && !is_string(_inst[$ "profileSelector"])) show_error($"{_where} :: 'profileSelector' expected string", true);
}

/**
 * @func ElementsJWK_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsJWK_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsJWK_validate";
	
	if (!is_undefined(_inst[$ "alg"]) && !is_string(_inst[$ "alg"])) show_error($"{_where} :: 'alg' expected string", true);
	if (!is_undefined(_inst[$ "kid"]) && !is_string(_inst[$ "kid"])) show_error($"{_where} :: 'kid' expected string", true);
	if (!is_undefined(_inst[$ "kty"]) && !is_string(_inst[$ "kty"])) show_error($"{_where} :: 'kty' expected string", true);
	if (!is_undefined(_inst[$ "use"]) && !is_string(_inst[$ "use"])) show_error($"{_where} :: 'use' expected string", true);
	if (!is_undefined(_inst[$ "e"]) && !is_string(_inst[$ "e"])) show_error($"{_where} :: 'e' expected string", true);
	if (!is_undefined(_inst[$ "n"]) && !is_string(_inst[$ "n"])) show_error($"{_where} :: 'n' expected string", true);
}

/**
 * @func ElementsOidcAuthScheme_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsOidcAuthScheme_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsOidcAuthScheme_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "issuer"])) show_error($"{_where} :: 'issuer' expected string", true);
	if (!is_array(_inst[$ "keys"])) show_error($"{_where} :: 'keys' expected ElementsJWK", true);
	if (!is_undefined(_inst[$ "name"]) && !is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_undefined(_inst[$ "keysUrl"]) && !is_string(_inst[$ "keysUrl"])) show_error($"{_where} :: 'keysUrl' expected string", true);
	if (!is_undefined(_inst[$ "mediaType"]) && !is_string(_inst[$ "mediaType"])) show_error($"{_where} :: 'mediaType' expected string", true);
}

/**
 * @func ElementsCreateOrUpdateOidcAuthSchemeResponse_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateOrUpdateOidcAuthSchemeResponse_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateOrUpdateOidcAuthSchemeResponse_validate";
	
	if (!is_undefined(_inst[$ "scheme"]))
	{
		if (!is_struct(_inst[$ "scheme"])) show_error($"{_where} :: 'scheme' expected ElementsOidcAuthScheme", true);
		ElementsOidcAuthScheme_validate(_inst[$ "scheme"], _where);
	}
}

/**
 * @func ElementsCreateOrUpdateOidcAuthSchemeRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateOrUpdateOidcAuthSchemeRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateOrUpdateOidcAuthSchemeRequest_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "issuer"])) show_error($"{_where} :: 'issuer' expected string", true);
	if (!is_array(_inst[$ "keys"])) show_error($"{_where} :: 'keys' expected ElementsJWK", true);
	if (!is_undefined(_inst[$ "keysUrl"]) && !is_string(_inst[$ "keysUrl"])) show_error($"{_where} :: 'keysUrl' expected string", true);
	if (!is_undefined(_inst[$ "mediaType"]) && !is_string(_inst[$ "mediaType"])) show_error($"{_where} :: 'mediaType' expected string", true);
}

/**
 * @func ElementsPaginationOidcAuthScheme_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationOidcAuthScheme_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationOidcAuthScheme_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsOidcAuthScheme", true);
}

/**
 * @func ElementsVaultKey_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsVaultKey_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsVaultKey_validate";
	
	if (!is_string(_inst[$ "algorithm"])) show_error($"{_where} :: 'algorithm' expected string", true);
	if (!is_string(_inst[$ "publicKey"])) show_error($"{_where} :: 'publicKey' expected string", true);
	if (!is_string(_inst[$ "privateKey"])) show_error($"{_where} :: 'privateKey' expected string", true);
	if (!is_undefined(_inst[$ "encrypted"]) && !is_real(_inst[$ "encrypted"])) show_error($"{_where} :: 'encrypted' expected bool", true);
	if (!is_undefined(_inst[$ "encryption"]) && !is_struct(_inst[$ "encryption"])) show_error($"{_where} :: 'encryption' expected any", true);
}

/**
 * @func ElementsVault_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsVault_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsVault_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_struct(_inst[$ "user"])) show_error($"{_where} :: 'user' expected ElementsUser", true);
	_inst[$ "user"].validate(_where);
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_struct(_inst[$ "key"])) show_error($"{_where} :: 'key' expected ElementsVaultKey", true);
	_inst[$ "key"].validate(_where);
}

/**
 * @func ElementsSmartContract_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsSmartContract_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsSmartContract_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_struct(_inst[$ "addresses"])) show_error($"{_where} :: 'addresses' expected any", true);
	if (!is_struct(_inst[$ "vault"])) show_error($"{_where} :: 'vault' expected ElementsVault", true);
	_inst[$ "vault"].validate(_where);
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
}

/**
 * @func ElementsSmartContractAddress_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsSmartContractAddress_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsSmartContractAddress_validate";
	
	if (!is_undefined(_inst[$ "address"]) && !is_string(_inst[$ "address"])) show_error($"{_where} :: 'address' expected string", true);
}

/**
 * @func ElementsCreateSmartContractRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateSmartContractRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateSmartContractRequest_validate";
	
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_struct(_inst[$ "addresses"])) show_error($"{_where} :: 'addresses' expected any", true);
	if (!is_string(_inst[$ "vaultId"])) show_error($"{_where} :: 'vaultId' expected string", true);
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
}

/**
 * @func ElementsPaginationSmartContract_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationSmartContract_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationSmartContract_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsSmartContract", true);
}

/**
 * @func ElementsUpdateSmartContractRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateSmartContractRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateSmartContractRequest_validate";
	
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_struct(_inst[$ "addresses"])) show_error($"{_where} :: 'addresses' expected any", true);
	if (!is_string(_inst[$ "vaultId"])) show_error($"{_where} :: 'vaultId' expected string", true);
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
}

/**
 * @func ElementsCreateVaultRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateVaultRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateVaultRequest_validate";
	
	if (!is_string(_inst[$ "userId"])) show_error($"{_where} :: 'userId' expected string", true);
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_undefined(_inst[$ "passphrase"]) && !is_string(_inst[$ "passphrase"])) show_error($"{_where} :: 'passphrase' expected string", true);
	if (!is_undefined(_inst[$ "algorithm"]) && !is_string(_inst[$ "algorithm"])) show_error($"{_where} :: 'algorithm' expected string", true);
}

/**
 * @func ElementsPaginationVault_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationVault_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationVault_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsVault", true);
}

/**
 * @func ElementsUpdateVaultRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateVaultRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateVaultRequest_validate";
	
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_string(_inst[$ "userId"])) show_error($"{_where} :: 'userId' expected string", true);
	if (!is_undefined(_inst[$ "passphrase"]) && !is_string(_inst[$ "passphrase"])) show_error($"{_where} :: 'passphrase' expected string", true);
	if (!is_undefined(_inst[$ "newPassphrase"]) && !is_string(_inst[$ "newPassphrase"])) show_error($"{_where} :: 'newPassphrase' expected string", true);
}

/**
 * @func ElementsWalletAccount_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsWalletAccount_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsWalletAccount_validate";
	
	if (!is_string(_inst[$ "address"])) show_error($"{_where} :: 'address' expected string", true);
	if (!is_undefined(_inst[$ "privateKey"]) && !is_string(_inst[$ "privateKey"])) show_error($"{_where} :: 'privateKey' expected string", true);
	if (!is_undefined(_inst[$ "encrypted"]) && !is_real(_inst[$ "encrypted"])) show_error($"{_where} :: 'encrypted' expected bool", true);
}

/**
 * @func ElementsWallet_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsWallet_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsWallet_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_struct(_inst[$ "user"])) show_error($"{_where} :: 'user' expected ElementsUser", true);
	_inst[$ "user"].validate(_where);
	if (!is_struct(_inst[$ "vault"])) show_error($"{_where} :: 'vault' expected ElementsVault", true);
	_inst[$ "vault"].validate(_where);
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_string(_inst[$ "api"])) show_error($"{_where} :: 'api' expected string", true);
	if (!is_array(_inst[$ "networks"])) show_error($"{_where} :: 'networks' expected string", true);
	if (!is_array(_inst[$ "accounts"])) show_error($"{_where} :: 'accounts' expected ElementsWalletAccount", true);
	if (!is_undefined(_inst[$ "preferredAccount"]) && !is_real(_inst[$ "preferredAccount"])) show_error($"{_where} :: 'preferredAccount' expected int32", true);
}

/**
 * @func ElementsCreateWalletRequestAccount_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateWalletRequestAccount_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateWalletRequestAccount_validate";
	
	if (!is_string(_inst[$ "address"])) show_error($"{_where} :: 'address' expected string", true);
	if (!is_undefined(_inst[$ "generate"]) && !is_real(_inst[$ "generate"])) show_error($"{_where} :: 'generate' expected bool", true);
	if (!is_undefined(_inst[$ "privateKey"]) && !is_string(_inst[$ "privateKey"])) show_error($"{_where} :: 'privateKey' expected string", true);
}

/**
 * @func ElementsCreateWalletRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateWalletRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateWalletRequest_validate";
	
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_string(_inst[$ "api"])) show_error($"{_where} :: 'api' expected string", true);
	if (!is_array(_inst[$ "networks"])) show_error($"{_where} :: 'networks' expected string", true);
	if (!is_array(_inst[$ "accounts"])) show_error($"{_where} :: 'accounts' expected ElementsCreateWalletRequestAccount", true);
	if (!is_undefined(_inst[$ "preferredAccount"]) && !is_real(_inst[$ "preferredAccount"])) show_error($"{_where} :: 'preferredAccount' expected int32", true);
}

/**
 * @func ElementsPaginationWallet_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationWallet_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationWallet_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsWallet", true);
}

/**
 * @func ElementsUpdateWalletRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateWalletRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateWalletRequest_validate";
	
	if (!is_array(_inst[$ "networks"])) show_error($"{_where} :: 'networks' expected string", true);
	if (!is_undefined(_inst[$ "displayName"]) && !is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_undefined(_inst[$ "preferredAccount"]) && !is_real(_inst[$ "preferredAccount"])) show_error($"{_where} :: 'preferredAccount' expected int32", true);
}

/**
 * @func ElementsDeployment_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsDeployment_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsDeployment_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "version"])) show_error($"{_where} :: 'version' expected string", true);
	if (!is_string(_inst[$ "revision"])) show_error($"{_where} :: 'revision' expected string", true);
	if (!is_struct(_inst[$ "application"])) show_error($"{_where} :: 'application' expected ElementsApplication", true);
	_inst[$ "application"].validate(_where);
}

/**
 * @func ElementsCreateDeploymentRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateDeploymentRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateDeploymentRequest_validate";
	
	if (!is_string(_inst[$ "version"])) show_error($"{_where} :: 'version' expected string", true);
	if (!is_string(_inst[$ "revision"])) show_error($"{_where} :: 'revision' expected string", true);
}

/**
 * @func ElementsPaginationDeployment_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationDeployment_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationDeployment_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsDeployment", true);
}

/**
 * @func ElementsUpdateDeploymentRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateDeploymentRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateDeploymentRequest_validate";
	
	if (!is_string(_inst[$ "revision"])) show_error($"{_where} :: 'revision' expected string", true);
}

/**
 * @func ElementsCodegenRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCodegenRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCodegenRequest_validate";
	
	if (!is_undefined(_inst[$ "elementSpecUrl"]) && !is_string(_inst[$ "elementSpecUrl"])) show_error($"{_where} :: 'elementSpecUrl' expected string", true);
	if (!is_undefined(_inst[$ "language"]) && !is_string(_inst[$ "language"])) show_error($"{_where} :: 'language' expected string", true);
	if (!is_undefined(_inst[$ "packageName"]) && !is_string(_inst[$ "packageName"])) show_error($"{_where} :: 'packageName' expected string", true);
	if (!is_undefined(_inst[$ "options"]) && !is_string(_inst[$ "options"])) show_error($"{_where} :: 'options' expected string", true);
}

/**
 * @func ElementsFilterRegistration_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsFilterRegistration_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsFilterRegistration_validate";
	
	if (!is_undefined(_inst[$ "servletNameMappings"]) && !is_array(_inst[$ "servletNameMappings"])) show_error($"{_where} :: 'servletNameMappings' expected string", true);
	if (!is_undefined(_inst[$ "urlPatternMappings"]) && !is_array(_inst[$ "urlPatternMappings"])) show_error($"{_where} :: 'urlPatternMappings' expected string", true);
	if (!is_undefined(_inst[$ "name"]) && !is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_undefined(_inst[$ "className"]) && !is_string(_inst[$ "className"])) show_error($"{_where} :: 'className' expected string", true);
	if (!is_undefined(_inst[$ "initParameters"]) && !is_struct(_inst[$ "initParameters"])) show_error($"{_where} :: 'initParameters' expected any", true);
}

/**
 * @func ElementsTaglibDescriptor_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsTaglibDescriptor_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsTaglibDescriptor_validate";
	
	if (!is_undefined(_inst[$ "taglibURI"]) && !is_string(_inst[$ "taglibURI"])) show_error($"{_where} :: 'taglibURI' expected string", true);
	if (!is_undefined(_inst[$ "taglibLocation"]) && !is_string(_inst[$ "taglibLocation"])) show_error($"{_where} :: 'taglibLocation' expected string", true);
}

/**
 * @func ElementsJspPropertyGroupDescriptor_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsJspPropertyGroupDescriptor_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsJspPropertyGroupDescriptor_validate";
	
	if (!is_undefined(_inst[$ "buffer"]) && !is_string(_inst[$ "buffer"])) show_error($"{_where} :: 'buffer' expected string", true);
	if (!is_undefined(_inst[$ "urlPatterns"]) && !is_array(_inst[$ "urlPatterns"])) show_error($"{_where} :: 'urlPatterns' expected string", true);
	if (!is_undefined(_inst[$ "elIgnored"]) && !is_string(_inst[$ "elIgnored"])) show_error($"{_where} :: 'elIgnored' expected string", true);
	if (!is_undefined(_inst[$ "isXml"]) && !is_string(_inst[$ "isXml"])) show_error($"{_where} :: 'isXml' expected string", true);
	if (!is_undefined(_inst[$ "errorOnELNotFound"]) && !is_string(_inst[$ "errorOnELNotFound"])) show_error($"{_where} :: 'errorOnELNotFound' expected string", true);
	if (!is_undefined(_inst[$ "pageEncoding"]) && !is_string(_inst[$ "pageEncoding"])) show_error($"{_where} :: 'pageEncoding' expected string", true);
	if (!is_undefined(_inst[$ "scriptingInvalid"]) && !is_string(_inst[$ "scriptingInvalid"])) show_error($"{_where} :: 'scriptingInvalid' expected string", true);
	if (!is_undefined(_inst[$ "includePreludes"]) && !is_array(_inst[$ "includePreludes"])) show_error($"{_where} :: 'includePreludes' expected string", true);
	if (!is_undefined(_inst[$ "includeCodas"]) && !is_array(_inst[$ "includeCodas"])) show_error($"{_where} :: 'includeCodas' expected string", true);
	if (!is_undefined(_inst[$ "defaultContentType"]) && !is_string(_inst[$ "defaultContentType"])) show_error($"{_where} :: 'defaultContentType' expected string", true);
	if (!is_undefined(_inst[$ "trimDirectiveWhitespaces"]) && !is_string(_inst[$ "trimDirectiveWhitespaces"])) show_error($"{_where} :: 'trimDirectiveWhitespaces' expected string", true);
	if (!is_undefined(_inst[$ "errorOnUndeclaredNamespace"]) && !is_string(_inst[$ "errorOnUndeclaredNamespace"])) show_error($"{_where} :: 'errorOnUndeclaredNamespace' expected string", true);
	if (!is_undefined(_inst[$ "deferredSyntaxAllowedAsLiteral"]) && !is_string(_inst[$ "deferredSyntaxAllowedAsLiteral"])) show_error($"{_where} :: 'deferredSyntaxAllowedAsLiteral' expected string", true);
}

/**
 * @func ElementsJspConfigDescriptor_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsJspConfigDescriptor_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsJspConfigDescriptor_validate";
	
	if (!is_undefined(_inst[$ "taglibs"]) && !is_array(_inst[$ "taglibs"])) show_error($"{_where} :: 'taglibs' expected ElementsTaglibDescriptor", true);
	if (!is_undefined(_inst[$ "jspPropertyGroups"]) && !is_array(_inst[$ "jspPropertyGroups"])) show_error($"{_where} :: 'jspPropertyGroups' expected ElementsJspPropertyGroupDescriptor", true);
}

/**
 * @func ElementsSessionCookieConfig_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsSessionCookieConfig_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsSessionCookieConfig_validate";
	
	if (!is_undefined(_inst[$ "path"]) && !is_string(_inst[$ "path"])) show_error($"{_where} :: 'path' expected string", true);
	if (!is_undefined(_inst[$ "domain"]) && !is_string(_inst[$ "domain"])) show_error($"{_where} :: 'domain' expected string", true);
	if (!is_undefined(_inst[$ "name"]) && !is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_undefined(_inst[$ "attributes"]) && !is_struct(_inst[$ "attributes"])) show_error($"{_where} :: 'attributes' expected any", true);
	if (!is_undefined(_inst[$ "comment"]) && !is_string(_inst[$ "comment"])) show_error($"{_where} :: 'comment' expected string", true);
	if (!is_undefined(_inst[$ "httpOnly"]) && !is_real(_inst[$ "httpOnly"])) show_error($"{_where} :: 'httpOnly' expected bool", true);
	if (!is_undefined(_inst[$ "secure"]) && !is_real(_inst[$ "secure"])) show_error($"{_where} :: 'secure' expected bool", true);
	if (!is_undefined(_inst[$ "maxAge"]) && !is_real(_inst[$ "maxAge"])) show_error($"{_where} :: 'maxAge' expected int32", true);
}

/**
 * @func ElementsServletContext_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsServletContext_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsServletContext_validate";
	
	if (!is_undefined(_inst[$ "classLoader"]) && !is_struct(_inst[$ "classLoader"])) show_error($"{_where} :: 'classLoader' expected any", true);
	if (!is_undefined(_inst[$ "majorVersion"]) && !is_real(_inst[$ "majorVersion"])) show_error($"{_where} :: 'majorVersion' expected int32", true);
	if (!is_undefined(_inst[$ "minorVersion"]) && !is_real(_inst[$ "minorVersion"])) show_error($"{_where} :: 'minorVersion' expected int32", true);
	if (!is_undefined(_inst[$ "contextPath"]) && !is_string(_inst[$ "contextPath"])) show_error($"{_where} :: 'contextPath' expected string", true);
	if (!is_undefined(_inst[$ "serverInfo"]) && !is_string(_inst[$ "serverInfo"])) show_error($"{_where} :: 'serverInfo' expected string", true);
	if (!is_undefined(_inst[$ "attributeNames"]) && !is_struct(_inst[$ "attributeNames"])) show_error($"{_where} :: 'attributeNames' expected any", true);
	if (!is_undefined(_inst[$ "servletContextName"]) && !is_string(_inst[$ "servletContextName"])) show_error($"{_where} :: 'servletContextName' expected string", true);
	if (!is_undefined(_inst[$ "filterRegistrations"]) && !is_struct(_inst[$ "filterRegistrations"])) show_error($"{_where} :: 'filterRegistrations' expected any", true);
	if (!is_undefined(_inst[$ "sessionCookieConfig"]))
	{
		if (!is_struct(_inst[$ "sessionCookieConfig"])) show_error($"{_where} :: 'sessionCookieConfig' expected ElementsSessionCookieConfig", true);
		ElementsSessionCookieConfig_validate(_inst[$ "sessionCookieConfig"], _where);
	}
	if (!is_undefined(_inst[$ "jspConfigDescriptor"]))
	{
		if (!is_struct(_inst[$ "jspConfigDescriptor"])) show_error($"{_where} :: 'jspConfigDescriptor' expected ElementsJspConfigDescriptor", true);
		ElementsJspConfigDescriptor_validate(_inst[$ "jspConfigDescriptor"], _where);
	}
	if (!is_undefined(_inst[$ "virtualServerName"]) && !is_string(_inst[$ "virtualServerName"])) show_error($"{_where} :: 'virtualServerName' expected string", true);
	if (!is_undefined(_inst[$ "sessionTimeout"]) && !is_real(_inst[$ "sessionTimeout"])) show_error($"{_where} :: 'sessionTimeout' expected int32", true);
	if (!is_undefined(_inst[$ "initParameterNames"]) && !is_struct(_inst[$ "initParameterNames"])) show_error($"{_where} :: 'initParameterNames' expected any", true);
	if (!is_undefined(_inst[$ "effectiveMajorVersion"]) && !is_real(_inst[$ "effectiveMajorVersion"])) show_error($"{_where} :: 'effectiveMajorVersion' expected int32", true);
	if (!is_undefined(_inst[$ "effectiveMinorVersion"]) && !is_real(_inst[$ "effectiveMinorVersion"])) show_error($"{_where} :: 'effectiveMinorVersion' expected int32", true);
	if (!is_undefined(_inst[$ "servletRegistrations"]) && !is_struct(_inst[$ "servletRegistrations"])) show_error($"{_where} :: 'servletRegistrations' expected any", true);
	if (!is_undefined(_inst[$ "sessionTrackingModes"]) && !is_array(_inst[$ "sessionTrackingModes"])) show_error($"{_where} :: 'sessionTrackingModes' expected string", true);
	if (!is_undefined(_inst[$ "defaultSessionTrackingModes"]) && !is_array(_inst[$ "defaultSessionTrackingModes"])) show_error($"{_where} :: 'defaultSessionTrackingModes' expected string", true);
	if (!is_undefined(_inst[$ "requestCharacterEncoding"]) && !is_string(_inst[$ "requestCharacterEncoding"])) show_error($"{_where} :: 'requestCharacterEncoding' expected string", true);
	if (!is_undefined(_inst[$ "responseCharacterEncoding"]) && !is_string(_inst[$ "responseCharacterEncoding"])) show_error($"{_where} :: 'responseCharacterEncoding' expected string", true);
	if (!is_undefined(_inst[$ "effectiveSessionTrackingModes"]) && !is_array(_inst[$ "effectiveSessionTrackingModes"])) show_error($"{_where} :: 'effectiveSessionTrackingModes' expected string", true);
}

/**
 * @func ElementsServletConfig_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsServletConfig_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsServletConfig_validate";
	
	if (!is_undefined(_inst[$ "servletName"]) && !is_string(_inst[$ "servletName"])) show_error($"{_where} :: 'servletName' expected string", true);
	if (!is_undefined(_inst[$ "servletContext"]))
	{
		if (!is_struct(_inst[$ "servletContext"])) show_error($"{_where} :: 'servletContext' expected ElementsServletContext", true);
		ElementsServletContext_validate(_inst[$ "servletContext"], _where);
	}
	if (!is_undefined(_inst[$ "initParameterNames"]) && !is_struct(_inst[$ "initParameterNames"])) show_error($"{_where} :: 'initParameterNames' expected any", true);
}

/**
 * @func ElementsServletRegistration_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsServletRegistration_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsServletRegistration_validate";
	
	if (!is_undefined(_inst[$ "mappings"]) && !is_array(_inst[$ "mappings"])) show_error($"{_where} :: 'mappings' expected string", true);
	if (!is_undefined(_inst[$ "runAsRole"]) && !is_string(_inst[$ "runAsRole"])) show_error($"{_where} :: 'runAsRole' expected string", true);
	if (!is_undefined(_inst[$ "name"]) && !is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_undefined(_inst[$ "className"]) && !is_string(_inst[$ "className"])) show_error($"{_where} :: 'className' expected string", true);
	if (!is_undefined(_inst[$ "initParameters"]) && !is_struct(_inst[$ "initParameters"])) show_error($"{_where} :: 'initParameters' expected any", true);
}

/**
 * @func ElementsPaginationProfile_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationProfile_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationProfile_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsProfile", true);
}

/**
 * @func ElementsCreateFollowerRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateFollowerRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateFollowerRequest_validate";
	
	if (!is_string(_inst[$ "followedId"])) show_error($"{_where} :: 'followedId' expected string", true);
}

/**
 * @func ElementsFriend_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsFriend_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsFriend_validate";
	
	if (!is_undefined(_inst[$ "id"]) && !is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_undefined(_inst[$ "user"]))
	{
		if (!is_struct(_inst[$ "user"])) show_error($"{_where} :: 'user' expected ElementsUser", true);
		ElementsUser_validate(_inst[$ "user"], _where);
	}
	if (!is_undefined(_inst[$ "friendship"]) && !is_string(_inst[$ "friendship"])) show_error($"{_where} :: 'friendship' expected string", true);
	if (!is_undefined(_inst[$ "profiles"]) && !is_array(_inst[$ "profiles"])) show_error($"{_where} :: 'profiles' expected ElementsProfile", true);
}

/**
 * @func ElementsPaginationFriend_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationFriend_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationFriend_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsFriend", true);
}

/**
 * @func ElementsCreateItemRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateItemRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateItemRequest_validate";
	
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_string(_inst[$ "category"])) show_error($"{_where} :: 'category' expected string", true);
	if (!is_undefined(_inst[$ "tags"]) && !is_array(_inst[$ "tags"])) show_error($"{_where} :: 'tags' expected string", true);
	if (!is_undefined(_inst[$ "metadataSpecId"]) && !is_string(_inst[$ "metadataSpecId"])) show_error($"{_where} :: 'metadataSpecId' expected string", true);
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
	if (!is_undefined(_inst[$ "publicVisible"]) && !is_real(_inst[$ "publicVisible"])) show_error($"{_where} :: 'publicVisible' expected bool", true);
	if (!is_undefined(_inst[$ "metadataSpec"]) && !is_string(_inst[$ "metadataSpec"])) show_error($"{_where} :: 'metadataSpec' expected string", true);
}

/**
 * @func ElementsPaginationItem_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationItem_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationItem_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsItem", true);
}

/**
 * @func ElementsUpdateItemRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateItemRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateItemRequest_validate";
	
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_undefined(_inst[$ "tags"]) && !is_array(_inst[$ "tags"])) show_error($"{_where} :: 'tags' expected string", true);
	if (!is_undefined(_inst[$ "metadataSpec"]))
	{
		if (!is_struct(_inst[$ "metadataSpec"])) show_error($"{_where} :: 'metadataSpec' expected ElementsMetadataSpec", true);
		ElementsMetadataSpec_validate(_inst[$ "metadataSpec"], _where);
	}
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
	if (!is_undefined(_inst[$ "publicVisible"]) && !is_real(_inst[$ "publicVisible"])) show_error($"{_where} :: 'publicVisible' expected bool", true);
}

/**
 * @func ElementsCreateGooglePlayIapReceipt_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateGooglePlayIapReceipt_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateGooglePlayIapReceipt_validate";
	
	if (!is_string(_inst[$ "packageName"])) show_error($"{_where} :: 'packageName' expected string", true);
	if (!is_string(_inst[$ "productId"])) show_error($"{_where} :: 'productId' expected string", true);
	if (!is_string(_inst[$ "purchaseToken"])) show_error($"{_where} :: 'purchaseToken' expected string", true);
}

/**
 * @func ElementsBuildIndexRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsBuildIndexRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsBuildIndexRequest_validate";
	
	if (!is_undefined(_inst[$ "plan"]) && !is_real(_inst[$ "plan"])) show_error($"{_where} :: 'plan' expected bool", true);
	if (!is_undefined(_inst[$ "toIndex"]) && !is_array(_inst[$ "toIndex"])) show_error($"{_where} :: 'toIndex' expected string", true);
}

/**
 * @func ElementsIndexMetadataObject_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsIndexMetadataObject_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsIndexMetadataObject_validate";
	
	if (!is_undefined(_inst[$ "identifier"]) && !is_struct(_inst[$ "identifier"])) show_error($"{_where} :: 'identifier' expected any", true);
}

/**
 * @func ElementsIndexPlanStepObject_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsIndexPlanStepObject_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsIndexPlanStepObject_validate";
	
	if (!is_undefined(_inst[$ "description"]) && !is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_undefined(_inst[$ "operation"]) && !is_string(_inst[$ "operation"])) show_error($"{_where} :: 'operation' expected string", true);
	if (!is_undefined(_inst[$ "indexMetadata"]))
	{
		if (!is_struct(_inst[$ "indexMetadata"])) show_error($"{_where} :: 'indexMetadata' expected ElementsIndexMetadataObject", true);
		ElementsIndexMetadataObject_validate(_inst[$ "indexMetadata"], _where);
	}
}

/**
 * @func ElementsIndexPlanObject_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsIndexPlanObject_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsIndexPlanObject_validate";
	
	if (!is_undefined(_inst[$ "id"]) && !is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_undefined(_inst[$ "state"]) && !is_string(_inst[$ "state"])) show_error($"{_where} :: 'state' expected string", true);
	if (!is_undefined(_inst[$ "steps"]))
	{
		if (!is_struct(_inst[$ "steps"])) show_error($"{_where} :: 'steps' expected ElementsIndexPlanStepObject", true);
		ElementsIndexPlanStepObject_validate(_inst[$ "steps"], _where);
	}
}

/**
 * @func ElementsPaginationIndexPlanObject_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationIndexPlanObject_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationIndexPlanObject_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsIndexPlanObject", true);
}

/**
 * @func ElementsInventoryItem_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsInventoryItem_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsInventoryItem_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_struct(_inst[$ "user"])) show_error($"{_where} :: 'user' expected ElementsUser", true);
	_inst[$ "user"].validate(_where);
	if (!is_struct(_inst[$ "item"])) show_error($"{_where} :: 'item' expected ElementsItem", true);
	_inst[$ "item"].validate(_where);
	if (!is_real(_inst[$ "quantity"])) show_error($"{_where} :: 'quantity' expected int32", true);
	if (!is_real(_inst[$ "priority"])) show_error($"{_where} :: 'priority' expected int32", true);
}

/**
 * @func ElementsAdvancedInventoryItemQuantityAdjustment_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsAdvancedInventoryItemQuantityAdjustment_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsAdvancedInventoryItemQuantityAdjustment_validate";
	
	if (!is_string(_inst[$ "userId"])) show_error($"{_where} :: 'userId' expected string", true);
	if (!is_real(_inst[$ "quantityDelta"])) show_error($"{_where} :: 'quantityDelta' expected int32", true);
	if (!is_undefined(_inst[$ "priority"]) && !is_real(_inst[$ "priority"])) show_error($"{_where} :: 'priority' expected int32", true);
}

/**
 * @func ElementsCreateAdvancedInventoryItemRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateAdvancedInventoryItemRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateAdvancedInventoryItemRequest_validate";
	
	if (!is_string(_inst[$ "userId"])) show_error($"{_where} :: 'userId' expected string", true);
	if (!is_string(_inst[$ "itemId"])) show_error($"{_where} :: 'itemId' expected string", true);
	if (!is_undefined(_inst[$ "quantity"]) && !is_real(_inst[$ "quantity"])) show_error($"{_where} :: 'quantity' expected int32", true);
	if (!is_undefined(_inst[$ "priority"]) && !is_real(_inst[$ "priority"])) show_error($"{_where} :: 'priority' expected int32", true);
}

/**
 * @func ElementsPaginationInventoryItem_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationInventoryItem_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationInventoryItem_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsInventoryItem", true);
}

/**
 * @func ElementsUpdateInventoryItemRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateInventoryItemRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateInventoryItemRequest_validate";
	
	if (!is_undefined(_inst[$ "quantity"]) && !is_real(_inst[$ "quantity"])) show_error($"{_where} :: 'quantity' expected int32", true);
}

/**
 * @func ElementsDistinctInventoryItem_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsDistinctInventoryItem_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsDistinctInventoryItem_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_struct(_inst[$ "item"])) show_error($"{_where} :: 'item' expected ElementsItem", true);
	_inst[$ "item"].validate(_where);
	if (!is_struct(_inst[$ "user"])) show_error($"{_where} :: 'user' expected ElementsUser", true);
	_inst[$ "user"].validate(_where);
	if (!is_undefined(_inst[$ "profile"]))
	{
		if (!is_struct(_inst[$ "profile"])) show_error($"{_where} :: 'profile' expected ElementsProfile", true);
		ElementsProfile_validate(_inst[$ "profile"], _where);
	}
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
}

/**
 * @func ElementsCreateDistinctInventoryItemRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateDistinctInventoryItemRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateDistinctInventoryItemRequest_validate";
	
	if (!is_string(_inst[$ "itemId"])) show_error($"{_where} :: 'itemId' expected string", true);
	if (!is_undefined(_inst[$ "userId"]) && !is_string(_inst[$ "userId"])) show_error($"{_where} :: 'userId' expected string", true);
	if (!is_undefined(_inst[$ "profileId"]) && !is_string(_inst[$ "profileId"])) show_error($"{_where} :: 'profileId' expected string", true);
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
}

/**
 * @func ElementsPaginationDistinctInventoryItem_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationDistinctInventoryItem_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationDistinctInventoryItem_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsDistinctInventoryItem", true);
}

/**
 * @func ElementsUpdateDistinctInventoryItemRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateDistinctInventoryItemRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateDistinctInventoryItemRequest_validate";
	
	if (!is_undefined(_inst[$ "userId"]) && !is_string(_inst[$ "userId"])) show_error($"{_where} :: 'userId' expected string", true);
	if (!is_undefined(_inst[$ "profileId"]) && !is_string(_inst[$ "profileId"])) show_error($"{_where} :: 'profileId' expected string", true);
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
}

/**
 * @func ElementsSimpleInventoryItemQuantityAdjustment_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsSimpleInventoryItemQuantityAdjustment_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsSimpleInventoryItemQuantityAdjustment_validate";
	
	if (!is_string(_inst[$ "userId"])) show_error($"{_where} :: 'userId' expected string", true);
	if (!is_real(_inst[$ "quantityDelta"])) show_error($"{_where} :: 'quantityDelta' expected int32", true);
}

/**
 * @func ElementsCreateSimpleInventoryItemRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateSimpleInventoryItemRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateSimpleInventoryItemRequest_validate";
	
	if (!is_string(_inst[$ "userId"])) show_error($"{_where} :: 'userId' expected string", true);
	if (!is_string(_inst[$ "itemId"])) show_error($"{_where} :: 'itemId' expected string", true);
	if (!is_undefined(_inst[$ "quantity"]) && !is_real(_inst[$ "quantity"])) show_error($"{_where} :: 'quantity' expected int32", true);
}

/**
 * @func ElementsPhoneMatchedInvitation_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPhoneMatchedInvitation_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPhoneMatchedInvitation_validate";
	
	if (!is_undefined(_inst[$ "phoneNumber"]) && !is_string(_inst[$ "phoneNumber"])) show_error($"{_where} :: 'phoneNumber' expected string", true);
	if (!is_undefined(_inst[$ "profileIds"]) && !is_array(_inst[$ "profileIds"])) show_error($"{_where} :: 'profileIds' expected string", true);
}

/**
 * @func ElementsInviteViaPhonesResponse_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsInviteViaPhonesResponse_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsInviteViaPhonesResponse_validate";
	
	if (!is_undefined(_inst[$ "matched"]) && !is_array(_inst[$ "matched"])) show_error($"{_where} :: 'matched' expected ElementsPhoneMatchedInvitation", true);
}

/**
 * @func ElementsInviteViaPhonesRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsInviteViaPhonesRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsInviteViaPhonesRequest_validate";
	
	if (!is_undefined(_inst[$ "phoneNumbers"]) && !is_array(_inst[$ "phoneNumbers"])) show_error($"{_where} :: 'phoneNumbers' expected string", true);
}

/**
 * @func ElementsSubjects_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsSubjects_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsSubjects_validate";
	
	if (!is_array(_inst[$ "users"])) show_error($"{_where} :: 'users' expected ElementsUser", true);
	if (!is_array(_inst[$ "profiles"])) show_error($"{_where} :: 'profiles' expected ElementsProfile", true);
	if (!is_undefined(_inst[$ "wildcard"]) && !is_real(_inst[$ "wildcard"])) show_error($"{_where} :: 'wildcard' expected bool", true);
}

/**
 * @func ElementsAccessPermissions_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsAccessPermissions_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsAccessPermissions_validate";
	
	if (!is_struct(_inst[$ "read"])) show_error($"{_where} :: 'read' expected ElementsSubjects", true);
	_inst[$ "read"].validate(_where);
	if (!is_struct(_inst[$ "write"])) show_error($"{_where} :: 'write' expected ElementsSubjects", true);
	_inst[$ "write"].validate(_where);
	if (!is_struct(_inst[$ "delete"])) show_error($"{_where} :: 'delete' expected ElementsSubjects", true);
	_inst[$ "delete"].validate(_where);
}

/**
 * @func ElementsLargeObject_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsLargeObject_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsLargeObject_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "path"])) show_error($"{_where} :: 'path' expected string", true);
	if (!is_struct(_inst[$ "accessPermissions"])) show_error($"{_where} :: 'accessPermissions' expected ElementsAccessPermissions", true);
	_inst[$ "accessPermissions"].validate(_where);
	if (!is_undefined(_inst[$ "url"]) && !is_string(_inst[$ "url"])) show_error($"{_where} :: 'url' expected string", true);
	if (!is_undefined(_inst[$ "mimeType"]) && !is_string(_inst[$ "mimeType"])) show_error($"{_where} :: 'mimeType' expected string", true);
	if (!is_undefined(_inst[$ "state"]) && !is_string(_inst[$ "state"])) show_error($"{_where} :: 'state' expected string", true);
	if (!is_undefined(_inst[$ "lastModified"]) && !is_string(_inst[$ "lastModified"])) show_error($"{_where} :: 'lastModified' expected string", true);
}

/**
 * @func ElementsContentDisposition_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsContentDisposition_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsContentDisposition_validate";
	
	if (!is_undefined(_inst[$ "type"]) && !is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
	if (!is_undefined(_inst[$ "parameters"]) && !is_struct(_inst[$ "parameters"])) show_error($"{_where} :: 'parameters' expected any", true);
	if (!is_undefined(_inst[$ "fileName"]) && !is_string(_inst[$ "fileName"])) show_error($"{_where} :: 'fileName' expected string", true);
	if (!is_undefined(_inst[$ "creationDate"]) && !is_string(_inst[$ "creationDate"])) show_error($"{_where} :: 'creationDate' expected string", true);
	if (!is_undefined(_inst[$ "modificationDate"]) && !is_string(_inst[$ "modificationDate"])) show_error($"{_where} :: 'modificationDate' expected string", true);
	if (!is_undefined(_inst[$ "readDate"]) && !is_string(_inst[$ "readDate"])) show_error($"{_where} :: 'readDate' expected string", true);
	if (!is_undefined(_inst[$ "size"]) && !is_real(_inst[$ "size"])) show_error($"{_where} :: 'size' expected int64", true);
}

/**
 * @func ElementsMediaType_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsMediaType_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsMediaType_validate";
	
	if (!is_undefined(_inst[$ "type"]) && !is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
	if (!is_undefined(_inst[$ "subtype"]) && !is_string(_inst[$ "subtype"])) show_error($"{_where} :: 'subtype' expected string", true);
	if (!is_undefined(_inst[$ "parameters"]) && !is_struct(_inst[$ "parameters"])) show_error($"{_where} :: 'parameters' expected any", true);
	if (!is_undefined(_inst[$ "wildcardType"]) && !is_real(_inst[$ "wildcardType"])) show_error($"{_where} :: 'wildcardType' expected bool", true);
	if (!is_undefined(_inst[$ "wildcardSubtype"]) && !is_real(_inst[$ "wildcardSubtype"])) show_error($"{_where} :: 'wildcardSubtype' expected bool", true);
}

/**
 * @func ElementsMultiPart_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsMultiPart_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsMultiPart_validate";
	
	if (!is_undefined(_inst[$ "contentDisposition"]))
	{
		if (!is_struct(_inst[$ "contentDisposition"])) show_error($"{_where} :: 'contentDisposition' expected ElementsContentDisposition", true);
		ElementsContentDisposition_validate(_inst[$ "contentDisposition"], _where);
	}
	if (!is_undefined(_inst[$ "entity"]) && !is_struct(_inst[$ "entity"])) show_error($"{_where} :: 'entity' expected any", true);
	if (!is_undefined(_inst[$ "headers"]) && !is_struct(_inst[$ "headers"])) show_error($"{_where} :: 'headers' expected any", true);
	if (!is_undefined(_inst[$ "mediaType"]))
	{
		if (!is_struct(_inst[$ "mediaType"])) show_error($"{_where} :: 'mediaType' expected ElementsMediaType", true);
		ElementsMediaType_validate(_inst[$ "mediaType"], _where);
	}
	if (!is_undefined(_inst[$ "messageBodyWorkers"]) && !is_struct(_inst[$ "messageBodyWorkers"])) show_error($"{_where} :: 'messageBodyWorkers' expected any", true);
	if (!is_undefined(_inst[$ "parent"]))
	{
		if (!is_struct(_inst[$ "parent"])) show_error($"{_where} :: 'parent' expected ElementsMultiPart", true);
		ElementsMultiPart_validate(_inst[$ "parent"], _where);
	}
	if (!is_undefined(_inst[$ "providers"]) && !is_struct(_inst[$ "providers"])) show_error($"{_where} :: 'providers' expected any", true);
	if (!is_undefined(_inst[$ "bodyParts"]) && !is_array(_inst[$ "bodyParts"])) show_error($"{_where} :: 'bodyParts' expected ElementsBodyPart", true);
	if (!is_undefined(_inst[$ "parameterizedHeaders"]) && !is_struct(_inst[$ "parameterizedHeaders"])) show_error($"{_where} :: 'parameterizedHeaders' expected any", true);
}

/**
 * @func ElementsBodyPart_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsBodyPart_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsBodyPart_validate";
	
	if (!is_undefined(_inst[$ "contentDisposition"]))
	{
		if (!is_struct(_inst[$ "contentDisposition"])) show_error($"{_where} :: 'contentDisposition' expected ElementsContentDisposition", true);
		ElementsContentDisposition_validate(_inst[$ "contentDisposition"], _where);
	}
	if (!is_undefined(_inst[$ "entity"]) && !is_struct(_inst[$ "entity"])) show_error($"{_where} :: 'entity' expected any", true);
	if (!is_undefined(_inst[$ "headers"]) && !is_struct(_inst[$ "headers"])) show_error($"{_where} :: 'headers' expected any", true);
	if (!is_undefined(_inst[$ "mediaType"]))
	{
		if (!is_struct(_inst[$ "mediaType"])) show_error($"{_where} :: 'mediaType' expected ElementsMediaType", true);
		ElementsMediaType_validate(_inst[$ "mediaType"], _where);
	}
	if (!is_undefined(_inst[$ "messageBodyWorkers"]) && !is_struct(_inst[$ "messageBodyWorkers"])) show_error($"{_where} :: 'messageBodyWorkers' expected any", true);
	if (!is_undefined(_inst[$ "parent"]))
	{
		if (!is_struct(_inst[$ "parent"])) show_error($"{_where} :: 'parent' expected ElementsMultiPart", true);
		ElementsMultiPart_validate(_inst[$ "parent"], _where);
	}
	if (!is_undefined(_inst[$ "providers"]) && !is_struct(_inst[$ "providers"])) show_error($"{_where} :: 'providers' expected any", true);
	if (!is_undefined(_inst[$ "parameterizedHeaders"]) && !is_struct(_inst[$ "parameterizedHeaders"])) show_error($"{_where} :: 'parameterizedHeaders' expected any", true);
}

/**
 * @func ElementsFormDataContentDisposition_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsFormDataContentDisposition_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsFormDataContentDisposition_validate";
	
	if (!is_undefined(_inst[$ "type"]) && !is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
	if (!is_undefined(_inst[$ "parameters"]) && !is_struct(_inst[$ "parameters"])) show_error($"{_where} :: 'parameters' expected any", true);
	if (!is_undefined(_inst[$ "fileName"]) && !is_string(_inst[$ "fileName"])) show_error($"{_where} :: 'fileName' expected string", true);
	if (!is_undefined(_inst[$ "creationDate"]) && !is_string(_inst[$ "creationDate"])) show_error($"{_where} :: 'creationDate' expected string", true);
	if (!is_undefined(_inst[$ "modificationDate"]) && !is_string(_inst[$ "modificationDate"])) show_error($"{_where} :: 'modificationDate' expected string", true);
	if (!is_undefined(_inst[$ "readDate"]) && !is_string(_inst[$ "readDate"])) show_error($"{_where} :: 'readDate' expected string", true);
	if (!is_undefined(_inst[$ "size"]) && !is_real(_inst[$ "size"])) show_error($"{_where} :: 'size' expected int64", true);
	if (!is_undefined(_inst[$ "name"]) && !is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
}

/**
 * @func ElementsFormDataBodyPart_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsFormDataBodyPart_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsFormDataBodyPart_validate";
	
	if (!is_undefined(_inst[$ "contentDisposition"]))
	{
		if (!is_struct(_inst[$ "contentDisposition"])) show_error($"{_where} :: 'contentDisposition' expected ElementsContentDisposition", true);
		ElementsContentDisposition_validate(_inst[$ "contentDisposition"], _where);
	}
	if (!is_undefined(_inst[$ "entity"]) && !is_struct(_inst[$ "entity"])) show_error($"{_where} :: 'entity' expected any", true);
	if (!is_undefined(_inst[$ "headers"]) && !is_struct(_inst[$ "headers"])) show_error($"{_where} :: 'headers' expected any", true);
	if (!is_undefined(_inst[$ "mediaType"]))
	{
		if (!is_struct(_inst[$ "mediaType"])) show_error($"{_where} :: 'mediaType' expected ElementsMediaType", true);
		ElementsMediaType_validate(_inst[$ "mediaType"], _where);
	}
	if (!is_undefined(_inst[$ "messageBodyWorkers"]) && !is_struct(_inst[$ "messageBodyWorkers"])) show_error($"{_where} :: 'messageBodyWorkers' expected any", true);
	if (!is_undefined(_inst[$ "parent"]))
	{
		if (!is_struct(_inst[$ "parent"])) show_error($"{_where} :: 'parent' expected ElementsMultiPart", true);
		ElementsMultiPart_validate(_inst[$ "parent"], _where);
	}
	if (!is_undefined(_inst[$ "providers"]) && !is_struct(_inst[$ "providers"])) show_error($"{_where} :: 'providers' expected any", true);
	if (!is_undefined(_inst[$ "name"]) && !is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_undefined(_inst[$ "value"]) && !is_string(_inst[$ "value"])) show_error($"{_where} :: 'value' expected string", true);
	if (!is_undefined(_inst[$ "content"]) && !is_struct(_inst[$ "content"])) show_error($"{_where} :: 'content' expected any", true);
	if (!is_undefined(_inst[$ "fileName"]) && !is_string(_inst[$ "fileName"])) show_error($"{_where} :: 'fileName' expected string", true);
	if (!is_undefined(_inst[$ "simple"]) && !is_real(_inst[$ "simple"])) show_error($"{_where} :: 'simple' expected bool", true);
	if (!is_undefined(_inst[$ "formDataContentDisposition"]))
	{
		if (!is_struct(_inst[$ "formDataContentDisposition"])) show_error($"{_where} :: 'formDataContentDisposition' expected ElementsFormDataContentDisposition", true);
		ElementsFormDataContentDisposition_validate(_inst[$ "formDataContentDisposition"], _where);
	}
	if (!is_undefined(_inst[$ "parameterizedHeaders"]) && !is_struct(_inst[$ "parameterizedHeaders"])) show_error($"{_where} :: 'parameterizedHeaders' expected any", true);
}

/**
 * @func ElementsMultivaluedMapStringParameterizedHeader_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsMultivaluedMapStringParameterizedHeader_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsMultivaluedMapStringParameterizedHeader_validate";
	
	if (!is_undefined(_inst[$ "empty"]) && !is_real(_inst[$ "empty"])) show_error($"{_where} :: 'empty' expected bool", true);
}

/**
 * @func ElementsMultivaluedMapStringString_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsMultivaluedMapStringString_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsMultivaluedMapStringString_validate";
	
	if (!is_undefined(_inst[$ "empty"]) && !is_real(_inst[$ "empty"])) show_error($"{_where} :: 'empty' expected bool", true);
}

/**
 * @func ElementsParameterizedHeader_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsParameterizedHeader_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsParameterizedHeader_validate";
	
	if (!is_undefined(_inst[$ "value"]) && !is_string(_inst[$ "value"])) show_error($"{_where} :: 'value' expected string", true);
	if (!is_undefined(_inst[$ "parameters"]) && !is_struct(_inst[$ "parameters"])) show_error($"{_where} :: 'parameters' expected any", true);
}

/**
 * @func ElementsSubjectRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsSubjectRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsSubjectRequest_validate";
	
	if (!is_array(_inst[$ "userIds"])) show_error($"{_where} :: 'userIds' expected string", true);
	if (!is_array(_inst[$ "profileIds"])) show_error($"{_where} :: 'profileIds' expected string", true);
	if (!is_undefined(_inst[$ "wildcard"]) && !is_real(_inst[$ "wildcard"])) show_error($"{_where} :: 'wildcard' expected bool", true);
}

/**
 * @func ElementsCreateLargeObjectRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateLargeObjectRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateLargeObjectRequest_validate";
	
	if (!is_string(_inst[$ "mimeType"])) show_error($"{_where} :: 'mimeType' expected string", true);
	if (!is_struct(_inst[$ "read"])) show_error($"{_where} :: 'read' expected ElementsSubjectRequest", true);
	_inst[$ "read"].validate(_where);
	if (!is_struct(_inst[$ "write"])) show_error($"{_where} :: 'write' expected ElementsSubjectRequest", true);
	_inst[$ "write"].validate(_where);
	if (!is_struct(_inst[$ "delete"])) show_error($"{_where} :: 'delete' expected ElementsSubjectRequest", true);
	_inst[$ "delete"].validate(_where);
}

/**
 * @func ElementsCreateLargeObjectFromUrlRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateLargeObjectFromUrlRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateLargeObjectFromUrlRequest_validate";
	
	if (!is_string(_inst[$ "mimeType"])) show_error($"{_where} :: 'mimeType' expected string", true);
	if (!is_struct(_inst[$ "read"])) show_error($"{_where} :: 'read' expected ElementsSubjectRequest", true);
	_inst[$ "read"].validate(_where);
	if (!is_struct(_inst[$ "write"])) show_error($"{_where} :: 'write' expected ElementsSubjectRequest", true);
	_inst[$ "write"].validate(_where);
	if (!is_struct(_inst[$ "delete"])) show_error($"{_where} :: 'delete' expected ElementsSubjectRequest", true);
	_inst[$ "delete"].validate(_where);
	if (!is_string(_inst[$ "fileUrl"])) show_error($"{_where} :: 'fileUrl' expected string", true);
}

/**
 * @func ElementsUpdateLargeObjectRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateLargeObjectRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateLargeObjectRequest_validate";
	
	if (!is_string(_inst[$ "mimeType"])) show_error($"{_where} :: 'mimeType' expected string", true);
	if (!is_struct(_inst[$ "read"])) show_error($"{_where} :: 'read' expected ElementsSubjectRequest", true);
	_inst[$ "read"].validate(_where);
	if (!is_struct(_inst[$ "write"])) show_error($"{_where} :: 'write' expected ElementsSubjectRequest", true);
	_inst[$ "write"].validate(_where);
	if (!is_struct(_inst[$ "delete"])) show_error($"{_where} :: 'delete' expected ElementsSubjectRequest", true);
	_inst[$ "delete"].validate(_where);
}

/**
 * @func ElementsLeaderboard_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsLeaderboard_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsLeaderboard_validate";
	
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "timeStrategyType"])) show_error($"{_where} :: 'timeStrategyType' expected string", true);
	if (!is_string(_inst[$ "scoreStrategyType"])) show_error($"{_where} :: 'scoreStrategyType' expected string", true);
	if (!is_string(_inst[$ "title"])) show_error($"{_where} :: 'title' expected string", true);
	if (!is_string(_inst[$ "scoreUnits"])) show_error($"{_where} :: 'scoreUnits' expected string", true);
	if (!is_undefined(_inst[$ "id"]) && !is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_undefined(_inst[$ "firstEpochTimestamp"]) && !is_real(_inst[$ "firstEpochTimestamp"])) show_error($"{_where} :: 'firstEpochTimestamp' expected int64", true);
	if (!is_undefined(_inst[$ "epochInterval"]) && !is_real(_inst[$ "epochInterval"])) show_error($"{_where} :: 'epochInterval' expected int64", true);
}

/**
 * @func ElementsPaginationLeaderboard_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationLeaderboard_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationLeaderboard_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsLeaderboard", true);
}

/**
 * @func ElementsScore_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsScore_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsScore_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_struct(_inst[$ "profile"])) show_error($"{_where} :: 'profile' expected ElementsProfile", true);
	_inst[$ "profile"].validate(_where);
	if (!is_real(_inst[$ "creationTimestamp"])) show_error($"{_where} :: 'creationTimestamp' expected int64", true);
	if (!is_real(_inst[$ "leaderboardEpoch"])) show_error($"{_where} :: 'leaderboardEpoch' expected int64", true);
	if (!is_undefined(_inst[$ "pointValue"]) && !is_real(_inst[$ "pointValue"])) show_error($"{_where} :: 'pointValue' expected double", true);
	if (!is_undefined(_inst[$ "scoreUnits"]) && !is_string(_inst[$ "scoreUnits"])) show_error($"{_where} :: 'scoreUnits' expected string", true);
}

/**
 * @func ElementsRank_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsRank_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsRank_validate";
	
	if (!is_struct(_inst[$ "score"])) show_error($"{_where} :: 'score' expected ElementsScore", true);
	_inst[$ "score"].validate(_where);
	if (!is_undefined(_inst[$ "position"]) && !is_real(_inst[$ "position"])) show_error($"{_where} :: 'position' expected int64", true);
}

/**
 * @func ElementsPaginationRank_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationRank_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationRank_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsRank", true);
}

/**
 * @func ElementsRankRow_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsRankRow_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsRankRow_validate";
	
	if (!is_string(_inst[$ "profileId"])) show_error($"{_where} :: 'profileId' expected string", true);
	if (!is_string(_inst[$ "profileDisplayName"])) show_error($"{_where} :: 'profileDisplayName' expected string", true);
	if (!is_string(_inst[$ "profileImageUrl"])) show_error($"{_where} :: 'profileImageUrl' expected string", true);
	if (!is_real(_inst[$ "lastLogin"])) show_error($"{_where} :: 'lastLogin' expected int64", true);
	if (!is_undefined(_inst[$ "id"]) && !is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_undefined(_inst[$ "position"]) && !is_real(_inst[$ "position"])) show_error($"{_where} :: 'position' expected int64", true);
	if (!is_undefined(_inst[$ "pointValue"]) && !is_real(_inst[$ "pointValue"])) show_error($"{_where} :: 'pointValue' expected double", true);
	if (!is_undefined(_inst[$ "scoreUnits"]) && !is_string(_inst[$ "scoreUnits"])) show_error($"{_where} :: 'scoreUnits' expected string", true);
	if (!is_undefined(_inst[$ "creationTimestamp"]) && !is_real(_inst[$ "creationTimestamp"])) show_error($"{_where} :: 'creationTimestamp' expected int64", true);
	if (!is_undefined(_inst[$ "leaderboardEpoch"]) && !is_real(_inst[$ "leaderboardEpoch"])) show_error($"{_where} :: 'leaderboardEpoch' expected int64", true);
}

/**
 * @func ElementsTabulationRankRow_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsTabulationRankRow_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsTabulationRankRow_validate";
	
	if (!is_array(_inst[$ "rows"])) show_error($"{_where} :: 'rows' expected ElementsRankRow", true);
}

/**
 * @func ElementsMatch_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsMatch_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsMatch_validate";
	
	if (!is_string(_inst[$ "scheme"])) show_error($"{_where} :: 'scheme' expected string", true);
	if (!is_struct(_inst[$ "player"])) show_error($"{_where} :: 'player' expected ElementsProfile", true);
	_inst[$ "player"].validate(_where);
	if (!is_undefined(_inst[$ "id"]) && !is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_undefined(_inst[$ "scope"]) && !is_string(_inst[$ "scope"])) show_error($"{_where} :: 'scope' expected string", true);
	if (!is_undefined(_inst[$ "opponent"]))
	{
		if (!is_struct(_inst[$ "opponent"])) show_error($"{_where} :: 'opponent' expected ElementsProfile", true);
		ElementsProfile_validate(_inst[$ "opponent"], _where);
	}
	if (!is_undefined(_inst[$ "lastUpdatedTimestamp"]) && !is_real(_inst[$ "lastUpdatedTimestamp"])) show_error($"{_where} :: 'lastUpdatedTimestamp' expected int64", true);
	if (!is_undefined(_inst[$ "gameId"]) && !is_string(_inst[$ "gameId"])) show_error($"{_where} :: 'gameId' expected string", true);
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
}

/**
 * @func ElementsPaginationMatch_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationMatch_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationMatch_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsMatch", true);
}

/**
 * @func ElementsMetadata_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsMetadata_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsMetadata_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
	if (!is_string(_inst[$ "accessLevel"])) show_error($"{_where} :: 'accessLevel' expected string", true);
	if (!is_undefined(_inst[$ "metadataSpec"]))
	{
		if (!is_struct(_inst[$ "metadataSpec"])) show_error($"{_where} :: 'metadataSpec' expected ElementsMetadataSpec", true);
		ElementsMetadataSpec_validate(_inst[$ "metadataSpec"], _where);
	}
}

/**
 * @func ElementsCreateMetadataRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateMetadataRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateMetadataRequest_validate";
	
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
	if (!is_undefined(_inst[$ "metadataSpec"]))
	{
		if (!is_struct(_inst[$ "metadataSpec"])) show_error($"{_where} :: 'metadataSpec' expected ElementsMetadataSpec", true);
		ElementsMetadataSpec_validate(_inst[$ "metadataSpec"], _where);
	}
	if (!is_undefined(_inst[$ "accessLevel"]) && !is_string(_inst[$ "accessLevel"])) show_error($"{_where} :: 'accessLevel' expected string", true);
}

/**
 * @func ElementsPaginationMetadata_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationMetadata_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationMetadata_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsMetadata", true);
}

/**
 * @func ElementsUpdateMetadataRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateMetadataRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateMetadataRequest_validate";
	
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
	if (!is_undefined(_inst[$ "metadataSpec"]))
	{
		if (!is_struct(_inst[$ "metadataSpec"])) show_error($"{_where} :: 'metadataSpec' expected ElementsMetadataSpec", true);
		ElementsMetadataSpec_validate(_inst[$ "metadataSpec"], _where);
	}
	if (!is_undefined(_inst[$ "accessLevel"]) && !is_string(_inst[$ "accessLevel"])) show_error($"{_where} :: 'accessLevel' expected string", true);
}

/**
 * @func ElementsReward_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsReward_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsReward_validate";
	
	if (!is_struct(_inst[$ "item"])) show_error($"{_where} :: 'item' expected ElementsItem", true);
	_inst[$ "item"].validate(_where);
	if (!is_real(_inst[$ "quantity"])) show_error($"{_where} :: 'quantity' expected int32", true);
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
}

/**
 * @func ElementsStep_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsStep_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsStep_validate";
	
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_real(_inst[$ "count"])) show_error($"{_where} :: 'count' expected int32", true);
	if (!is_array(_inst[$ "rewards"])) show_error($"{_where} :: 'rewards' expected ElementsReward", true);
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
}

/**
 * @func ElementsMission_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsMission_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsMission_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_undefined(_inst[$ "tags"]) && !is_array(_inst[$ "tags"])) show_error($"{_where} :: 'tags' expected string", true);
	if (!is_undefined(_inst[$ "steps"]) && !is_array(_inst[$ "steps"])) show_error($"{_where} :: 'steps' expected ElementsStep", true);
	if (!is_undefined(_inst[$ "finalRepeatStep"]))
	{
		if (!is_struct(_inst[$ "finalRepeatStep"])) show_error($"{_where} :: 'finalRepeatStep' expected ElementsStep", true);
		ElementsStep_validate(_inst[$ "finalRepeatStep"], _where);
	}
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
}

/**
 * @func ElementsPaginationMission_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationMission_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationMission_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsMission", true);
}

/**
 * @func ElementsProgressMissionInfo_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsProgressMissionInfo_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsProgressMissionInfo_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_undefined(_inst[$ "steps"]) && !is_array(_inst[$ "steps"])) show_error($"{_where} :: 'steps' expected ElementsStep", true);
	if (!is_undefined(_inst[$ "finalRepeatStep"]))
	{
		if (!is_struct(_inst[$ "finalRepeatStep"])) show_error($"{_where} :: 'finalRepeatStep' expected ElementsStep", true);
		ElementsStep_validate(_inst[$ "finalRepeatStep"], _where);
	}
	if (!is_undefined(_inst[$ "tags"]) && !is_array(_inst[$ "tags"])) show_error($"{_where} :: 'tags' expected string", true);
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
}

/**
 * @func ElementsSchedule_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsSchedule_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsSchedule_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
}

/**
 * @func ElementsScheduleEvent_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsScheduleEvent_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsScheduleEvent_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_struct(_inst[$ "schedule"])) show_error($"{_where} :: 'schedule' expected ElementsSchedule", true);
	_inst[$ "schedule"].validate(_where);
	if (!is_array(_inst[$ "missions"])) show_error($"{_where} :: 'missions' expected ElementsMission", true);
	if (!is_undefined(_inst[$ "begin"]) && !is_real(_inst[$ "begin"])) show_error($"{_where} :: 'begin' expected int64", true);
	if (!is_undefined(_inst[$ "end"]) && !is_real(_inst[$ "end"])) show_error($"{_where} :: 'end' expected int64", true);
}

/**
 * @func ElementsProgress_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsProgress_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsProgress_validate";
	
	if (!is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_struct(_inst[$ "profile"])) show_error($"{_where} :: 'profile' expected ElementsProfile", true);
	_inst[$ "profile"].validate(_where);
	if (!is_struct(_inst[$ "mission"])) show_error($"{_where} :: 'mission' expected ElementsProgressMissionInfo", true);
	_inst[$ "mission"].validate(_where);
	if (!is_undefined(_inst[$ "currentStep"]))
	{
		if (!is_struct(_inst[$ "currentStep"])) show_error($"{_where} :: 'currentStep' expected ElementsStep", true);
		ElementsStep_validate(_inst[$ "currentStep"], _where);
	}
	if (!is_undefined(_inst[$ "remaining"]) && !is_real(_inst[$ "remaining"])) show_error($"{_where} :: 'remaining' expected int32", true);
	if (!is_undefined(_inst[$ "rewardIssuances"]) && !is_array(_inst[$ "rewardIssuances"])) show_error($"{_where} :: 'rewardIssuances' expected ElementsRewardIssuance", true);
	if (!is_undefined(_inst[$ "sequence"]) && !is_real(_inst[$ "sequence"])) show_error($"{_where} :: 'sequence' expected int32", true);
	if (!is_undefined(_inst[$ "managedBySchedule"]) && !is_real(_inst[$ "managedBySchedule"])) show_error($"{_where} :: 'managedBySchedule' expected bool", true);
	if (!is_undefined(_inst[$ "schedules"]) && !is_array(_inst[$ "schedules"])) show_error($"{_where} :: 'schedules' expected ElementsSchedule", true);
	if (!is_undefined(_inst[$ "scheduleEvents"]) && !is_array(_inst[$ "scheduleEvents"])) show_error($"{_where} :: 'scheduleEvents' expected ElementsScheduleEvent", true);
}

/**
 * @func ElementsPaginationProgress_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationProgress_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationProgress_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsProgress", true);
}

/**
 * @func ElementsProgressRow_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsProgressRow_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsProgressRow_validate";
	
	if (!is_undefined(_inst[$ "id"]) && !is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_undefined(_inst[$ "profileId"]) && !is_string(_inst[$ "profileId"])) show_error($"{_where} :: 'profileId' expected string", true);
	if (!is_undefined(_inst[$ "profileImageUrl"]) && !is_string(_inst[$ "profileImageUrl"])) show_error($"{_where} :: 'profileImageUrl' expected string", true);
	if (!is_undefined(_inst[$ "profileDisplayName"]) && !is_string(_inst[$ "profileDisplayName"])) show_error($"{_where} :: 'profileDisplayName' expected string", true);
	if (!is_undefined(_inst[$ "stepDisplayName"]) && !is_string(_inst[$ "stepDisplayName"])) show_error($"{_where} :: 'stepDisplayName' expected string", true);
	if (!is_undefined(_inst[$ "stepDescription"]) && !is_string(_inst[$ "stepDescription"])) show_error($"{_where} :: 'stepDescription' expected string", true);
	if (!is_undefined(_inst[$ "remaining"]) && !is_real(_inst[$ "remaining"])) show_error($"{_where} :: 'remaining' expected int32", true);
	if (!is_undefined(_inst[$ "stepCount"]) && !is_real(_inst[$ "stepCount"])) show_error($"{_where} :: 'stepCount' expected int32", true);
}

/**
 * @func ElementsTabulationProgressRow_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsTabulationProgressRow_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsTabulationProgressRow_validate";
	
	if (!is_array(_inst[$ "rows"])) show_error($"{_where} :: 'rows' expected ElementsProgressRow", true);
}

/**
 * @func ElementsPaginationRewardIssuance_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationRewardIssuance_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationRewardIssuance_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsRewardIssuance", true);
}

/**
 * @func ElementsRewardIssuanceRedemptionResult_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsRewardIssuanceRedemptionResult_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsRewardIssuanceRedemptionResult_validate";
	
	if (!is_undefined(_inst[$ "rewardIssuanceId"]) && !is_string(_inst[$ "rewardIssuanceId"])) show_error($"{_where} :: 'rewardIssuanceId' expected string", true);
	if (!is_undefined(_inst[$ "rewardIssuance"]))
	{
		if (!is_struct(_inst[$ "rewardIssuance"])) show_error($"{_where} :: 'rewardIssuance' expected ElementsRewardIssuance", true);
		ElementsRewardIssuance_validate(_inst[$ "rewardIssuance"], _where);
	}
	if (!is_undefined(_inst[$ "inventoryItem"]))
	{
		if (!is_struct(_inst[$ "inventoryItem"])) show_error($"{_where} :: 'inventoryItem' expected ElementsInventoryItem", true);
		ElementsInventoryItem_validate(_inst[$ "inventoryItem"], _where);
	}
	if (!is_undefined(_inst[$ "errorDetails"]) && !is_string(_inst[$ "errorDetails"])) show_error($"{_where} :: 'errorDetails' expected string", true);
}

/**
 * @func ElementsCreateScheduleEventRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateScheduleEventRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateScheduleEventRequest_validate";
	
	if (!is_array(_inst[$ "missionNamesOrIds"])) show_error($"{_where} :: 'missionNamesOrIds' expected string", true);
	if (!is_undefined(_inst[$ "begin"]) && !is_real(_inst[$ "begin"])) show_error($"{_where} :: 'begin' expected int64", true);
	if (!is_undefined(_inst[$ "end"]) && !is_real(_inst[$ "end"])) show_error($"{_where} :: 'end' expected int64", true);
}

/**
 * @func ElementsPaginationScheduleEvent_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationScheduleEvent_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationScheduleEvent_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsScheduleEvent", true);
}

/**
 * @func ElementsUpdateScheduleEventRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateScheduleEventRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateScheduleEventRequest_validate";
	
	if (!is_array(_inst[$ "missionNamesOrIds"])) show_error($"{_where} :: 'missionNamesOrIds' expected string", true);
	if (!is_undefined(_inst[$ "begin"]) && !is_real(_inst[$ "begin"])) show_error($"{_where} :: 'begin' expected int64", true);
	if (!is_undefined(_inst[$ "end"]) && !is_real(_inst[$ "end"])) show_error($"{_where} :: 'end' expected int64", true);
}

/**
 * @func ElementsCreateScheduleRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateScheduleRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateScheduleRequest_validate";
	
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
}

/**
 * @func ElementsPaginationSchedule_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationSchedule_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationSchedule_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsSchedule", true);
}

/**
 * @func ElementsUpdateScheduleRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateScheduleRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateScheduleRequest_validate";
	
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
}

/**
 * @func ElementsFCMRegistration_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsFCMRegistration_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsFCMRegistration_validate";
	
	if (!is_string(_inst[$ "registrationToken"])) show_error($"{_where} :: 'registrationToken' expected string", true);
	if (!is_undefined(_inst[$ "id"]) && !is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_undefined(_inst[$ "profile"]))
	{
		if (!is_struct(_inst[$ "profile"])) show_error($"{_where} :: 'profile' expected ElementsProfile", true);
		ElementsProfile_validate(_inst[$ "profile"], _where);
	}
}

/**
 * @func ElementsCreateProfileRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateProfileRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateProfileRequest_validate";
	
	if (!is_string(_inst[$ "userId"])) show_error($"{_where} :: 'userId' expected string", true);
	if (!is_string(_inst[$ "applicationId"])) show_error($"{_where} :: 'applicationId' expected string", true);
	if (!is_undefined(_inst[$ "imageUrl"]) && !is_string(_inst[$ "imageUrl"])) show_error($"{_where} :: 'imageUrl' expected string", true);
	if (!is_undefined(_inst[$ "displayName"]) && !is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
}

/**
 * @func ElementsUpdateProfileRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateProfileRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateProfileRequest_validate";
	
	if (!is_undefined(_inst[$ "imageUrl"]) && !is_string(_inst[$ "imageUrl"])) show_error($"{_where} :: 'imageUrl' expected string", true);
	if (!is_undefined(_inst[$ "displayName"]) && !is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_undefined(_inst[$ "metadata"]) && !is_struct(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected any", true);
}

/**
 * @func ElementsUpdateProfileImageRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateProfileImageRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateProfileImageRequest_validate";
	
	if (!is_string(_inst[$ "mimeType"])) show_error($"{_where} :: 'mimeType' expected string", true);
}

/**
 * @func ElementsSaveDataDocument_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsSaveDataDocument_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsSaveDataDocument_validate";
	
	if (!is_string(_inst[$ "version"])) show_error($"{_where} :: 'version' expected string", true);
	if (!is_string(_inst[$ "contents"])) show_error($"{_where} :: 'contents' expected string", true);
	if (!is_undefined(_inst[$ "id"]) && !is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_undefined(_inst[$ "slot"]) && !is_real(_inst[$ "slot"])) show_error($"{_where} :: 'slot' expected int32", true);
	if (!is_undefined(_inst[$ "user"]))
	{
		if (!is_struct(_inst[$ "user"])) show_error($"{_where} :: 'user' expected ElementsUser", true);
		ElementsUser_validate(_inst[$ "user"], _where);
	}
	if (!is_undefined(_inst[$ "profile"]))
	{
		if (!is_struct(_inst[$ "profile"])) show_error($"{_where} :: 'profile' expected ElementsProfile", true);
		ElementsProfile_validate(_inst[$ "profile"], _where);
	}
	if (!is_undefined(_inst[$ "timestamp"]) && !is_real(_inst[$ "timestamp"])) show_error($"{_where} :: 'timestamp' expected int64", true);
}

/**
 * @func ElementsCreateSaveDataDocumentRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateSaveDataDocumentRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateSaveDataDocumentRequest_validate";
	
	if (!is_real(_inst[$ "slot"])) show_error($"{_where} :: 'slot' expected int32", true);
	if (!is_string(_inst[$ "contents"])) show_error($"{_where} :: 'contents' expected string", true);
	if (!is_undefined(_inst[$ "userId"]) && !is_string(_inst[$ "userId"])) show_error($"{_where} :: 'userId' expected string", true);
	if (!is_undefined(_inst[$ "profileId"]) && !is_string(_inst[$ "profileId"])) show_error($"{_where} :: 'profileId' expected string", true);
}

/**
 * @func ElementsPaginationSaveDataDocument_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationSaveDataDocument_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationSaveDataDocument_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsSaveDataDocument", true);
}

/**
 * @func ElementsUpdateSaveDataDocumentRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateSaveDataDocumentRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateSaveDataDocumentRequest_validate";
	
	if (!is_string(_inst[$ "contents"])) show_error($"{_where} :: 'contents' expected string", true);
	if (!is_undefined(_inst[$ "force"]) && !is_real(_inst[$ "force"])) show_error($"{_where} :: 'force' expected bool", true);
	if (!is_undefined(_inst[$ "version"]) && !is_string(_inst[$ "version"])) show_error($"{_where} :: 'version' expected string", true);
}

/**
 * @func ElementsCreateMetadataSpecRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateMetadataSpecRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateMetadataSpecRequest_validate";
	
	if (!is_array(_inst[$ "properties"])) show_error($"{_where} :: 'properties' expected ElementsMetadataSpecProperty", true);
	if (!is_undefined(_inst[$ "name"]) && !is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_undefined(_inst[$ "type"]) && !is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
}

/**
 * @func ElementsEditorLayout_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsEditorLayout_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsEditorLayout_validate";
	
	if (!is_undefined(_inst[$ "key"]) && !is_string(_inst[$ "key"])) show_error($"{_where} :: 'key' expected string", true);
	if (!is_undefined(_inst[$ "title"]) && !is_string(_inst[$ "title"])) show_error($"{_where} :: 'title' expected string", true);
	if (!is_undefined(_inst[$ "placeholder"]) && !is_string(_inst[$ "placeholder"])) show_error($"{_where} :: 'placeholder' expected string", true);
}

/**
 * @func ElementsJsonSchema_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsJsonSchema_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsJsonSchema_validate";
	
	if (!is_undefined(_inst[$ "get$id"]) && !is_string(_inst[$ "get$id"])) show_error($"{_where} :: 'get$id' expected string", true);
	if (!is_undefined(_inst[$ "get$schema"]) && !is_string(_inst[$ "get$schema"])) show_error($"{_where} :: 'get$schema' expected string", true);
	if (!is_undefined(_inst[$ "title"]) && !is_string(_inst[$ "title"])) show_error($"{_where} :: 'title' expected string", true);
	if (!is_undefined(_inst[$ "description"]) && !is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_undefined(_inst[$ "type"]) && !is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
	if (!is_undefined(_inst[$ "properties"]) && !is_struct(_inst[$ "properties"])) show_error($"{_where} :: 'properties' expected any", true);
	if (!is_undefined(_inst[$ "required"]) && !is_array(_inst[$ "required"])) show_error($"{_where} :: 'required' expected string", true);
}

/**
 * @func ElementsEditorSchema_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsEditorSchema_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsEditorSchema_validate";
	
	if (!is_undefined(_inst[$ "data"]) && !is_struct(_inst[$ "data"])) show_error($"{_where} :: 'data' expected any", true);
	if (!is_undefined(_inst[$ "schema"]))
	{
		if (!is_struct(_inst[$ "schema"])) show_error($"{_where} :: 'schema' expected ElementsJsonSchema", true);
		ElementsJsonSchema_validate(_inst[$ "schema"], _where);
	}
	if (!is_undefined(_inst[$ "layout"]) && !is_array(_inst[$ "layout"])) show_error($"{_where} :: 'layout' expected ElementsEditorLayout", true);
}

/**
 * @func ElementsJsonSchemaProperty_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsJsonSchemaProperty_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsJsonSchemaProperty_validate";
	
	if (!is_undefined(_inst[$ "type"]) && !is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
	if (!is_undefined(_inst[$ "title"]) && !is_string(_inst[$ "title"])) show_error($"{_where} :: 'title' expected string", true);
	if (!is_undefined(_inst[$ "description"]) && !is_string(_inst[$ "description"])) show_error($"{_where} :: 'description' expected string", true);
	if (!is_undefined(_inst[$ "required"]) && !is_array(_inst[$ "required"])) show_error($"{_where} :: 'required' expected string", true);
}

/**
 * @func ElementsPaginationMetadataSpec_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationMetadataSpec_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationMetadataSpec_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsMetadataSpec", true);
}

/**
 * @func ElementsUpdateMetadataSpecRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUpdateMetadataSpecRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUpdateMetadataSpecRequest_validate";
	
	if (!is_undefined(_inst[$ "name"]) && !is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_undefined(_inst[$ "type"]) && !is_string(_inst[$ "type"])) show_error($"{_where} :: 'type' expected string", true);
	if (!is_undefined(_inst[$ "properties"]) && !is_array(_inst[$ "properties"])) show_error($"{_where} :: 'properties' expected ElementsMetadataSpecProperty", true);
}

/**
 * @func ElementsMockSessionCreation_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsMockSessionCreation_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsMockSessionCreation_validate";
	
	if (!is_undefined(_inst[$ "sessionSecret"]) && !is_string(_inst[$ "sessionSecret"])) show_error($"{_where} :: 'sessionSecret' expected string", true);
	if (!is_undefined(_inst[$ "session"]))
	{
		if (!is_struct(_inst[$ "session"])) show_error($"{_where} :: 'session' expected ElementsSession", true);
		ElementsSession_validate(_inst[$ "session"], _where);
	}
	if (!is_undefined(_inst[$ "userExpiresAt"]) && !is_real(_inst[$ "userExpiresAt"])) show_error($"{_where} :: 'userExpiresAt' expected int64", true);
	if (!is_undefined(_inst[$ "password"]) && !is_string(_inst[$ "password"])) show_error($"{_where} :: 'password' expected string", true);
}

/**
 * @func ElementsMockSessionRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsMockSessionRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsMockSessionRequest_validate";
	
	if (!is_undefined(_inst[$ "lifetimeInSeconds"]) && !is_real(_inst[$ "lifetimeInSeconds"])) show_error($"{_where} :: 'lifetimeInSeconds' expected int32", true);
	if (!is_undefined(_inst[$ "application"]))
	{
		if (!is_struct(_inst[$ "application"])) show_error($"{_where} :: 'application' expected ElementsApplication", true);
		ElementsApplication_validate(_inst[$ "application"], _where);
	}
}

/**
 * @func ElementsUsernamePasswordSessionRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUsernamePasswordSessionRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUsernamePasswordSessionRequest_validate";
	
	if (!is_string(_inst[$ "userId"])) show_error($"{_where} :: 'userId' expected string", true);
	if (!is_string(_inst[$ "password"])) show_error($"{_where} :: 'password' expected string", true);
	if (!is_undefined(_inst[$ "profileId"]) && !is_string(_inst[$ "profileId"])) show_error($"{_where} :: 'profileId' expected string", true);
	if (!is_undefined(_inst[$ "profileSelector"]) && !is_string(_inst[$ "profileSelector"])) show_error($"{_where} :: 'profileSelector' expected string", true);
}

/**
 * @func ElementsDatabaseHealthStatus_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsDatabaseHealthStatus_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsDatabaseHealthStatus_validate";
	
	if (!is_undefined(_inst[$ "name"]) && !is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_undefined(_inst[$ "metadata"]) && !is_string(_inst[$ "metadata"])) show_error($"{_where} :: 'metadata' expected string", true);
}

/**
 * @func ElementsDiscoveryHealthStatus_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsDiscoveryHealthStatus_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsDiscoveryHealthStatus_validate";
	
	if (!is_undefined(_inst[$ "records"]) && !is_array(_inst[$ "records"])) show_error($"{_where} :: 'records' expected string", true);
	if (!is_undefined(_inst[$ "knownHosts"]) && !is_array(_inst[$ "knownHosts"])) show_error($"{_where} :: 'knownHosts' expected string", true);
}

/**
 * @func ElementsInstanceHealthStatus_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsInstanceHealthStatus_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsInstanceHealthStatus_validate";
	
	if (!is_undefined(_inst[$ "instanceId"]) && !is_string(_inst[$ "instanceId"])) show_error($"{_where} :: 'instanceId' expected string", true);
	if (!is_undefined(_inst[$ "nodeIds"]) && !is_array(_inst[$ "nodeIds"])) show_error($"{_where} :: 'nodeIds' expected string", true);
}

/**
 * @func ElementsRoutingHealthStatus_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsRoutingHealthStatus_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsRoutingHealthStatus_validate";
	
	if (!is_undefined(_inst[$ "instanceId"]) && !is_string(_inst[$ "instanceId"])) show_error($"{_where} :: 'instanceId' expected string", true);
	if (!is_undefined(_inst[$ "routingTable"]) && !is_array(_inst[$ "routingTable"])) show_error($"{_where} :: 'routingTable' expected string", true);
	if (!is_undefined(_inst[$ "masterNodeRoutingTable"]) && !is_array(_inst[$ "masterNodeRoutingTable"])) show_error($"{_where} :: 'masterNodeRoutingTable' expected string", true);
	if (!is_undefined(_inst[$ "applicationNodeRoutingTable"]) && !is_array(_inst[$ "applicationNodeRoutingTable"])) show_error($"{_where} :: 'applicationNodeRoutingTable' expected string", true);
}

/**
 * @func ElementsInvokerHealthStatus_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsInvokerHealthStatus_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsInvokerHealthStatus_validate";
	
	if (!is_undefined(_inst[$ "priorities"]) && !is_array(_inst[$ "priorities"])) show_error($"{_where} :: 'priorities' expected string", true);
	if (!is_undefined(_inst[$ "connectedPeers"]) && !is_array(_inst[$ "connectedPeers"])) show_error($"{_where} :: 'connectedPeers' expected string", true);
}

/**
 * @func ElementsHealthStatus_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsHealthStatus_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsHealthStatus_validate";
	
	if (!is_undefined(_inst[$ "checksFailed"]) && !is_real(_inst[$ "checksFailed"])) show_error($"{_where} :: 'checksFailed' expected int32", true);
	if (!is_undefined(_inst[$ "checksPerformed"]) && !is_real(_inst[$ "checksPerformed"])) show_error($"{_where} :: 'checksPerformed' expected int32", true);
	if (!is_undefined(_inst[$ "overallHealth"]) && !is_real(_inst[$ "overallHealth"])) show_error($"{_where} :: 'overallHealth' expected double", true);
	if (!is_undefined(_inst[$ "problems"]) && !is_array(_inst[$ "problems"])) show_error($"{_where} :: 'problems' expected string", true);
	if (!is_undefined(_inst[$ "instanceStatus"]))
	{
		if (!is_struct(_inst[$ "instanceStatus"])) show_error($"{_where} :: 'instanceStatus' expected ElementsInstanceHealthStatus", true);
		ElementsInstanceHealthStatus_validate(_inst[$ "instanceStatus"], _where);
	}
	if (!is_undefined(_inst[$ "databaseStatus"]) && !is_array(_inst[$ "databaseStatus"])) show_error($"{_where} :: 'databaseStatus' expected ElementsDatabaseHealthStatus", true);
	if (!is_undefined(_inst[$ "discoveryHealthStatus"]))
	{
		if (!is_struct(_inst[$ "discoveryHealthStatus"])) show_error($"{_where} :: 'discoveryHealthStatus' expected ElementsDiscoveryHealthStatus", true);
		ElementsDiscoveryHealthStatus_validate(_inst[$ "discoveryHealthStatus"], _where);
	}
	if (!is_undefined(_inst[$ "routingHealthStatus"]))
	{
		if (!is_struct(_inst[$ "routingHealthStatus"])) show_error($"{_where} :: 'routingHealthStatus' expected ElementsRoutingHealthStatus", true);
		ElementsRoutingHealthStatus_validate(_inst[$ "routingHealthStatus"], _where);
	}
	if (!is_undefined(_inst[$ "invokerHealthStatus"]))
	{
		if (!is_struct(_inst[$ "invokerHealthStatus"])) show_error($"{_where} :: 'invokerHealthStatus' expected ElementsInvokerHealthStatus", true);
		ElementsInvokerHealthStatus_validate(_inst[$ "invokerHealthStatus"], _where);
	}
}

/**
 * @func ElementsVersion_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsVersion_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsVersion_validate";
	
	if (!is_undefined(_inst[$ "version"]) && !is_string(_inst[$ "version"])) show_error($"{_where} :: 'version' expected string", true);
	if (!is_undefined(_inst[$ "revision"]) && !is_string(_inst[$ "revision"])) show_error($"{_where} :: 'revision' expected string", true);
	if (!is_undefined(_inst[$ "timestamp"]) && !is_string(_inst[$ "timestamp"])) show_error($"{_where} :: 'timestamp' expected string", true);
}

/**
 * @func ElementsUserCreateResponse_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUserCreateResponse_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUserCreateResponse_validate";
	
	if (!is_undefined(_inst[$ "id"]) && !is_string(_inst[$ "id"])) show_error($"{_where} :: 'id' expected string", true);
	if (!is_undefined(_inst[$ "name"]) && !is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_undefined(_inst[$ "email"]) && !is_string(_inst[$ "email"])) show_error($"{_where} :: 'email' expected string", true);
	if (!is_undefined(_inst[$ "firstName"]) && !is_string(_inst[$ "firstName"])) show_error($"{_where} :: 'firstName' expected string", true);
	if (!is_undefined(_inst[$ "lastName"]) && !is_string(_inst[$ "lastName"])) show_error($"{_where} :: 'lastName' expected string", true);
	if (!is_undefined(_inst[$ "level"]) && !is_string(_inst[$ "level"])) show_error($"{_where} :: 'level' expected string", true);
	if (!is_undefined(_inst[$ "active"]) && !is_real(_inst[$ "active"])) show_error($"{_where} :: 'active' expected bool", true);
	if (!is_undefined(_inst[$ "facebookId"]) && !is_string(_inst[$ "facebookId"])) show_error($"{_where} :: 'facebookId' expected string", true);
	if (!is_undefined(_inst[$ "firebaseId"]) && !is_string(_inst[$ "firebaseId"])) show_error($"{_where} :: 'firebaseId' expected string", true);
	if (!is_undefined(_inst[$ "appleSignInId"]) && !is_string(_inst[$ "appleSignInId"])) show_error($"{_where} :: 'appleSignInId' expected string", true);
	if (!is_undefined(_inst[$ "primaryPhoneNb"]) && !is_string(_inst[$ "primaryPhoneNb"])) show_error($"{_where} :: 'primaryPhoneNb' expected string", true);
	if (!is_undefined(_inst[$ "profiles"]) && !is_array(_inst[$ "profiles"])) show_error($"{_where} :: 'profiles' expected ElementsProfile", true);
	if (!is_undefined(_inst[$ "password"]) && !is_string(_inst[$ "password"])) show_error($"{_where} :: 'password' expected string", true);
	if (!is_undefined(_inst[$ "linkedAccounts"]) && !is_array(_inst[$ "linkedAccounts"])) show_error($"{_where} :: 'linkedAccounts' expected string", true);
}

/**
 * @func ElementsCreateProfileSignupRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsCreateProfileSignupRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsCreateProfileSignupRequest_validate";
	
	if (!is_string(_inst[$ "applicationId"])) show_error($"{_where} :: 'applicationId' expected string", true);
	if (!is_undefined(_inst[$ "displayName"]) && !is_string(_inst[$ "displayName"])) show_error($"{_where} :: 'displayName' expected string", true);
	if (!is_undefined(_inst[$ "imageUrl"]) && !is_string(_inst[$ "imageUrl"])) show_error($"{_where} :: 'imageUrl' expected string", true);
}

/**
 * @func ElementsUserCreateRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUserCreateRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUserCreateRequest_validate";
	
	if (!is_undefined(_inst[$ "name"]) && !is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_undefined(_inst[$ "email"]) && !is_string(_inst[$ "email"])) show_error($"{_where} :: 'email' expected string", true);
	if (!is_undefined(_inst[$ "primaryPhoneNb"]) && !is_string(_inst[$ "primaryPhoneNb"])) show_error($"{_where} :: 'primaryPhoneNb' expected string", true);
	if (!is_undefined(_inst[$ "firstName"]) && !is_string(_inst[$ "firstName"])) show_error($"{_where} :: 'firstName' expected string", true);
	if (!is_undefined(_inst[$ "lastName"]) && !is_string(_inst[$ "lastName"])) show_error($"{_where} :: 'lastName' expected string", true);
	if (!is_undefined(_inst[$ "password"]) && !is_string(_inst[$ "password"])) show_error($"{_where} :: 'password' expected string", true);
	if (!is_undefined(_inst[$ "level"]) && !is_string(_inst[$ "level"])) show_error($"{_where} :: 'level' expected string", true);
	if (!is_undefined(_inst[$ "profiles"]) && !is_array(_inst[$ "profiles"])) show_error($"{_where} :: 'profiles' expected ElementsCreateProfileSignupRequest", true);
}

/**
 * @func ElementsPaginationUser_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsPaginationUser_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsPaginationUser_validate";
	
	if (!is_undefined(_inst[$ "offset"]) && !is_real(_inst[$ "offset"])) show_error($"{_where} :: 'offset' expected int32", true);
	if (!is_undefined(_inst[$ "total"]) && !is_real(_inst[$ "total"])) show_error($"{_where} :: 'total' expected int32", true);
	if (!is_undefined(_inst[$ "approximation"]) && !is_real(_inst[$ "approximation"])) show_error($"{_where} :: 'approximation' expected bool", true);
	if (!is_undefined(_inst[$ "objects"]) && !is_array(_inst[$ "objects"])) show_error($"{_where} :: 'objects' expected ElementsUser", true);
}

/**
 * @func ElementsUserUpdateRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUserUpdateRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUserUpdateRequest_validate";
	
	if (!is_string(_inst[$ "name"])) show_error($"{_where} :: 'name' expected string", true);
	if (!is_string(_inst[$ "email"])) show_error($"{_where} :: 'email' expected string", true);
	if (!is_string(_inst[$ "level"])) show_error($"{_where} :: 'level' expected string", true);
	if (!is_undefined(_inst[$ "primaryPhoneNb"]) && !is_string(_inst[$ "primaryPhoneNb"])) show_error($"{_where} :: 'primaryPhoneNb' expected string", true);
	if (!is_undefined(_inst[$ "firstName"]) && !is_string(_inst[$ "firstName"])) show_error($"{_where} :: 'firstName' expected string", true);
	if (!is_undefined(_inst[$ "lastName"]) && !is_string(_inst[$ "lastName"])) show_error($"{_where} :: 'lastName' expected string", true);
	if (!is_undefined(_inst[$ "password"]) && !is_string(_inst[$ "password"])) show_error($"{_where} :: 'password' expected string", true);
}

/**
 * @func ElementsUserUpdatePasswordRequest_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsUserUpdatePasswordRequest_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsUserUpdatePasswordRequest_validate";
	
	if (!is_string(_inst[$ "oldPassword"])) show_error($"{_where} :: 'oldPassword' expected string", true);
	if (!is_string(_inst[$ "newPassword"])) show_error($"{_where} :: 'newPassword' expected string", true);
	if (!is_undefined(_inst[$ "profileId"]) && !is_string(_inst[$ "profileId"])) show_error($"{_where} :: 'profileId' expected string", true);
}

/**
 * @func ElementsErrorResponse_validate()
 * @param {Struct} _inst The struct to be validated.
 * @param {String} _where What is the callee of this function (used for debug).
 * @ignore 
 */
function ElementsErrorResponse_validate(_inst, _where = _GMFUNCTION_)
{
	_where = $"{_where} :: ElementsErrorResponse_validate";
	
	if (!is_undefined(_inst[$ "code"]) && !is_string(_inst[$ "code"])) show_error($"{_where} :: 'code' expected string", true);
	if (!is_undefined(_inst[$ "message"]) && !is_string(_inst[$ "message"])) show_error($"{_where} :: 'message' expected string", true);
}

